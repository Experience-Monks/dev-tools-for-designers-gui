'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _digestForObject = require('./digest-for-object');

var _digestForObject2 = _interopRequireDefault(_digestForObject);

var _promise = require('./promise');

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var d = require('debug')('electron-compile:compile-cache');

/**
 * CompileCache manages getting and setting entries for a single compiler; each
 * in-use compiler will have an instance of this class, usually created via
 * {@link createFromCompiler}. 
 * 
 * You usually will not use this class directly, it is an implementation class 
 * for {@link CompileHost}.
 */

var CompileCache = (function () {
  /**  
   * Creates an instance, usually used for testing only.
   *    
   * @param  {string} cachePath  The root directory to use as a cache path
   *
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is 
   *                                             optionally pre-loaded.
   */

  function CompileCache(cachePath, fileChangeCache) {
    _classCallCheck(this, CompileCache);

    this.cachePath = cachePath;
    this.fileChangeCache = fileChangeCache;
  }

  /**  
   * Creates a CompileCache from a class compatible with the CompilerBase 
   * interface. This method uses the compiler name / version / options to 
   * generate a unique directory name for cached results
   *    
   * @param  {string} cachePath  The root path to use for the cache, a directory
   *                             representing the hash of the compiler parameters
   *                             will be created here.
   *
   * @param  {CompilerBase} compiler  The compiler to use for version / option
   *                                  information.
   *
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is 
   *                                             optionally pre-loaded.
   *
   * @param  {boolean} readOnlyMode  Don't attempt to create the cache directory.
   *
   * @return {CompileCache}  A configured CompileCache instance.
   */

  _createClass(CompileCache, [{
    key: 'get',

    /**  
     * Returns a file's compiled contents from the cache.
     *    
     * @param  {string} filePath  The path to the file. FileChangedCache will look
     *                            up the hash and use that as the key in the cache.
     *
     * @return {Promise<Object>}  An object with all kinds of information
     *
     * @property {Object} hashInfo  The hash information returned from getHashForPath
     * @property {string} code  The source code if the file was a text file
     * @property {Buffer} binaryData  The file if it was a binary file
     * @property {string} mimeType  The MIME type saved in the cache.
     * @property {string[]} dependentFiles  The dependent files returned from 
     *                                      compiling the file, if any.
     */
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(filePath) {
        var hashInfo, code, mimeType, binaryData, dependentFiles, cacheFile, result, info, buf, str;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                d('Fetching ' + filePath + ' from cache');
                _context.next = 3;
                return this.fileChangeCache.getHashForPath(_path2.default.resolve(filePath));

              case 3:
                hashInfo = _context.sent;
                code = null;
                mimeType = null;
                binaryData = null;
                dependentFiles = null;
                cacheFile = null;
                _context.prev = 9;

                cacheFile = _path2.default.join(this.getCachePath(), hashInfo.hash);
                result = null;

                if (!hashInfo.isFileBinary) {
                  _context.next = 31;
                  break;
                }

                d("File is binary, reading out info");
                _context.t0 = JSON;
                _context.next = 17;
                return _promise.pfs.readFile(cacheFile + '.info');

              case 17:
                _context.t1 = _context.sent;
                info = _context.t0.parse.call(_context.t0, _context.t1);

                mimeType = info.mimeType;
                dependentFiles = info.dependentFiles;

                binaryData = hashInfo.binaryData;

                if (binaryData) {
                  _context.next = 29;
                  break;
                }

                _context.next = 25;
                return _promise.pfs.readFile(cacheFile);

              case 25:
                binaryData = _context.sent;
                _context.next = 28;
                return _promise.pzlib.gunzip(binaryData);

              case 28:
                binaryData = _context.sent;

              case 29:
                _context.next = 41;
                break;

              case 31:
                _context.next = 33;
                return _promise.pfs.readFile(cacheFile);

              case 33:
                buf = _context.sent;
                _context.next = 36;
                return _promise.pzlib.gunzip(buf);

              case 36:
                str = _context.sent.toString('utf8');

                result = JSON.parse(str);
                code = result.code;
                mimeType = result.mimeType;
                dependentFiles = result.dependentFiles;

              case 41:
                _context.next = 46;
                break;

              case 43:
                _context.prev = 43;
                _context.t2 = _context['catch'](9);

                d('Failed to read cache for ' + filePath + ', looked in ' + cacheFile + ': ' + _context.t2.message);

              case 46:
                return _context.abrupt('return', { hashInfo: hashInfo, code: code, mimeType: mimeType, binaryData: binaryData, dependentFiles: dependentFiles });

              case 47:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 43]]);
      }));

      return function get(_x) {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Saves a compiled result to cache
     *    
     * @param  {Object} hashInfo  The hash information returned from getHashForPath   
     *
     * @param  {string / Buffer} codeOrBinaryData   The file's contents, either as
     *                                              a string or a Buffer.
     * @param  {string} mimeType  The MIME type returned by the compiler.
     *
     * @param  {string[]} dependentFiles  The list of dependent files returned by
     *                                    the compiler.
     * @return {Promise}  Completion.
     */

  }, {
    key: 'save',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {
        var buf, target;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                buf = null;
                target = _path2.default.join(this.getCachePath(), hashInfo.hash);

                d('Saving to ' + target);

                if (!hashInfo.isFileBinary) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 6;
                return _promise.pzlib.gzip(codeOrBinaryData);

              case 6:
                buf = _context2.sent;
                _context2.next = 9;
                return _promise.pfs.writeFile(target + '.info', JSON.stringify({ mimeType: mimeType, dependentFiles: dependentFiles }), 'utf8');

              case 9:
                _context2.next = 14;
                break;

              case 11:
                _context2.next = 13;
                return _promise.pzlib.gzip(new Buffer(JSON.stringify({ code: codeOrBinaryData, mimeType: mimeType, dependentFiles: dependentFiles })));

              case 13:
                buf = _context2.sent;

              case 14:
                _context2.next = 16;
                return _promise.pfs.writeFile(target, buf);

              case 16:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function save(_x2, _x3, _x4, _x5) {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Attempts to first get a key via {@link get}, then if it fails, call a method
     * to retrieve the contents, then save the result to cache.
     * 
     * The fetcher parameter is expected to have the signature:
     * 
     * Promise<Object> fetcher(filePath : string, hashInfo : Object);
     * 
     * hashInfo is a value returned from getHashForPath
     * The return value of fetcher must be an Object with the properties:
     * 
     * mimeType - the MIME type of the data to save
     * code (optional) - the source code as a string, if file is text
     * binaryData (optional) - the file contents as a Buffer, if file is binary
     * dependentFiles - the dependent files returned by the compiler.
     *
     * @param  {string} filePath  The path to the file. FileChangedCache will look
     *                            up the hash and use that as the key in the cache.
     *
     * @param  {Function} fetcher  A method which conforms to the description above.
     *
     * @return {Promise<Object>}  An Object which has the same fields as the 
     *                            {@link get} method return result.
     */

  }, {
    key: 'getOrFetch',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(filePath, fetcher) {
        var cacheResult, result;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.get(filePath);

              case 2:
                cacheResult = _context3.sent;

                if (!(cacheResult.code || cacheResult.binaryData)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt('return', cacheResult);

              case 5:
                _context3.next = 7;
                return fetcher(filePath, cacheResult.hashInfo);

              case 7:
                _context3.t0 = _context3.sent;

                if (_context3.t0) {
                  _context3.next = 10;
                  break;
                }

                _context3.t0 = { hashInfo: cacheResult.hashInfo };

              case 10:
                result = _context3.t0;

                if (!(result.mimeType && !cacheResult.hashInfo.isInNodeModules)) {
                  _context3.next = 15;
                  break;
                }

                d('Cache miss: saving out info for ' + filePath);
                _context3.next = 15;
                return this.save(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);

              case 15:

                result.hashInfo = cacheResult.hashInfo;
                return _context3.abrupt('return', result);

              case 17:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getOrFetch(_x6, _x7) {
        return ref.apply(this, arguments);
      };
    })()
  }, {
    key: 'getSync',
    value: function getSync(filePath) {
      d('Fetching ' + filePath + ' from cache');
      var hashInfo = this.fileChangeCache.getHashForPathSync(_path2.default.resolve(filePath));

      var code = null;
      var mimeType = null;
      var binaryData = null;
      var dependentFiles = null;

      try {
        var cacheFile = _path2.default.join(this.getCachePath(), hashInfo.hash);

        var _result = null;
        if (hashInfo.isFileBinary) {
          d("File is binary, reading out info");
          var _info = JSON.parse(_fs2.default.readFileSync(cacheFile + '.info'));
          mimeType = _info.mimeType;
          dependentFiles = _info.dependentFiles;

          binaryData = hashInfo.binaryData;
          if (!binaryData) {
            binaryData = _fs2.default.readFileSync(cacheFile);
            binaryData = _zlib2.default.gunzipSync(binaryData);
          }
        } else {
          var _buf = _fs2.default.readFileSync(cacheFile);
          var _str = _zlib2.default.gunzipSync(_buf).toString('utf8');

          _result = JSON.parse(_str);
          code = _result.code;
          mimeType = _result.mimeType;
          dependentFiles = _result.dependentFiles;
        }
      } catch (e) {
        d('Failed to read cache for ' + filePath);
      }

      return { hashInfo: hashInfo, code: code, mimeType: mimeType, binaryData: binaryData, dependentFiles: dependentFiles };
    }
  }, {
    key: 'saveSync',
    value: function saveSync(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {
      var buf = null;
      var target = _path2.default.join(this.getCachePath(), hashInfo.hash);
      d('Saving to ' + target);

      if (hashInfo.isFileBinary) {
        buf = _zlib2.default.gzipSync(codeOrBinaryData);
        _fs2.default.writeFileSync(target + '.info', JSON.stringify({ mimeType: mimeType, dependentFiles: dependentFiles }), 'utf8');
      } else {
        buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify({ code: codeOrBinaryData, mimeType: mimeType, dependentFiles: dependentFiles })));
      }

      _fs2.default.writeFileSync(target, buf);
    }
  }, {
    key: 'getOrFetchSync',
    value: function getOrFetchSync(filePath, fetcher) {
      var cacheResult = this.getSync(filePath);
      if (cacheResult.code || cacheResult.binaryData) return cacheResult;

      var result = fetcher(filePath, cacheResult.hashInfo) || { hashInfo: cacheResult.hashInfo };

      if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {
        d('Cache miss: saving out info for ' + filePath);
        this.saveSync(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);
      }

      result.hashInfo = cacheResult.hashInfo;
      return result;
    }

    /**  
     * @private
     */

  }, {
    key: 'getCachePath',
    value: function getCachePath() {
      // NB: This is an evil hack so that createFromCompiler can stomp it
      // at will
      return this.cachePath;
    }

    /**    
     * Returns whether a file should not be compiled. Note that this doesn't 
     * necessarily mean it won't end up in the cache, only that its contents are
     * saved verbatim instead of trying to find an appropriate compiler.
     *    
     * @param  {Object} hashInfo  The hash information returned from getHashForPath   
     *
     * @return {boolean}  True if a file should be ignored
     */

  }], [{
    key: 'createFromCompiler',
    value: function createFromCompiler(cachePath, compiler, fileChangeCache) {
      var readOnlyMode = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var newCachePath = null;
      var getCachePath = function getCachePath() {
        if (newCachePath) return newCachePath;

        var digestObj = {
          name: compiler.name || Object.getPrototypeOf(compiler).constructor.name,
          version: compiler.getCompilerVersion(),
          options: compiler.compilerOptions
        };

        newCachePath = _path2.default.join(cachePath, (0, _digestForObject2.default)(digestObj));

        d('Path for ' + digestObj.name + ': ' + newCachePath);
        d('Set up with parameters: ' + JSON.stringify(digestObj));

        if (!readOnlyMode) _mkdirp2.default.sync(newCachePath);
        return newCachePath;
      };

      var ret = new CompileCache('', fileChangeCache);
      ret.getCachePath = getCachePath;

      return ret;
    }
  }, {
    key: 'shouldPassthrough',
    value: function shouldPassthrough(hashInfo) {
      return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
    }
  }]);

  return CompileCache;
})();

exports.default = CompileCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlLWNhY2hlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9BLElBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxnQ0FBZ0MsQ0FBQzs7Ozs7Ozs7OztBQUFDO0lBVXhDLFlBQVk7Ozs7Ozs7Ozs7QUFTL0IsV0FUbUIsWUFBWSxDQVNuQixTQUFTLEVBQUUsZUFBZSxFQUFFOzBCQVRyQixZQUFZOztBQVU3QixRQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUMzQixRQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztHQUN4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7ZUFaa0IsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRUEwRXJCLFFBQVE7WUFFWixRQUFRLEVBRVIsSUFBSSxFQUNKLFFBQVEsRUFDUixVQUFVLEVBQ1YsY0FBYyxFQUVkLFNBQVMsRUFHUCxNQUFNLEVBSUosSUFBSSxFQVVKLEdBQUcsRUFDSCxHQUFHOzs7OztBQTFCWCxpQkFBQyxlQUFhLFFBQVEsaUJBQWMsQ0FBQzs7dUJBQ2hCLElBQUksQ0FBQyxlQUFlLENBQUMsY0FBYyxDQUFDLGVBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7QUFBNUUsd0JBQVE7QUFFUixvQkFBSSxHQUFHLElBQUk7QUFDWCx3QkFBUSxHQUFHLElBQUk7QUFDZiwwQkFBVSxHQUFHLElBQUk7QUFDakIsOEJBQWMsR0FBRyxJQUFJO0FBRXJCLHlCQUFTLEdBQUcsSUFBSTs7O0FBRWxCLHlCQUFTLEdBQUcsZUFBSyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN0RCxzQkFBTSxHQUFHLElBQUk7O3FCQUViLFFBQVEsQ0FBQyxZQUFZOzs7OztBQUN2QixpQkFBQyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7OEJBQzNC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QUVoQyxhQUFPLEdBQUcsQ0FBQztLQUNaOzs7c0NBd053QixRQUFRLEVBQUU7QUFDakMsYUFBTyxRQUFRLENBQUMsVUFBVSxJQUFJLFFBQVEsQ0FBQyxlQUFlLElBQUksUUFBUSxDQUFDLFlBQVksSUFBSSxRQUFRLENBQUMsWUFBWSxDQUFDO0tBQzFHOzs7U0FuUmtCLFlBQVk7OztrQkFBWixZQUFZIiwiZmlsZSI6ImNvbXBpbGUtY2FjaGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBjcmVhdGVEaWdlc3RGb3JPYmplY3QgZnJvbSAnLi9kaWdlc3QtZm9yLW9iamVjdCc7XHJcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcclxuaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29tcGlsZS1jYWNoZScpO1xyXG5cclxuLyoqXHJcbiAqIENvbXBpbGVDYWNoZSBtYW5hZ2VzIGdldHRpbmcgYW5kIHNldHRpbmcgZW50cmllcyBmb3IgYSBzaW5nbGUgY29tcGlsZXI7IGVhY2hcclxuICogaW4tdXNlIGNvbXBpbGVyIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLCB1c3VhbGx5IGNyZWF0ZWQgdmlhXHJcbiAqIHtAbGluayBjcmVhdGVGcm9tQ29tcGlsZXJ9LiBcclxuICogXHJcbiAqIFlvdSB1c3VhbGx5IHdpbGwgbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCBpdCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBjbGFzcyBcclxuICogZm9yIHtAbGluayBDb21waWxlSG9zdH0uXHJcbiAqLyBcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGlsZUNhY2hlIHtcclxuICAvKiogIFxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2UsIHVzdWFsbHkgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxyXG4gICAqICAgIFxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FjaGVQYXRoICBUaGUgcm9vdCBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUgcGF0aFxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXMgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGx5IHByZS1sb2FkZWQuXHJcbiAgICovICAgXHJcbiAgY29uc3RydWN0b3IoY2FjaGVQYXRoLCBmaWxlQ2hhbmdlQ2FjaGUpIHtcclxuICAgIHRoaXMuY2FjaGVQYXRoID0gY2FjaGVQYXRoO1xyXG4gICAgdGhpcy5maWxlQ2hhbmdlQ2FjaGUgPSBmaWxlQ2hhbmdlQ2FjaGU7XHJcbiAgfVxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogQ3JlYXRlcyBhIENvbXBpbGVDYWNoZSBmcm9tIGEgY2xhc3MgY29tcGF0aWJsZSB3aXRoIHRoZSBDb21waWxlckJhc2UgXHJcbiAgICogaW50ZXJmYWNlLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21waWxlciBuYW1lIC8gdmVyc2lvbiAvIG9wdGlvbnMgdG8gXHJcbiAgICogZ2VuZXJhdGUgYSB1bmlxdWUgZGlyZWN0b3J5IG5hbWUgZm9yIGNhY2hlZCByZXN1bHRzXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjYWNoZVBhdGggIFRoZSByb290IHBhdGggdG8gdXNlIGZvciB0aGUgY2FjaGUsIGEgZGlyZWN0b3J5XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHJlc2VudGluZyB0aGUgaGFzaCBvZiB0aGUgY29tcGlsZXIgcGFyYW1ldGVyc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGNyZWF0ZWQgaGVyZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gY29tcGlsZXIgIFRoZSBjb21waWxlciB0byB1c2UgZm9yIHZlcnNpb24gLyBvcHRpb25cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0ZpbGVDaGFuZ2VkQ2FjaGV9IGZpbGVDaGFuZ2VDYWNoZSAgQSBmaWxlLWNoYW5nZSBjYWNoZSB0aGF0IGlzIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxseSBwcmUtbG9hZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmVhZE9ubHlNb2RlICBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSB0aGUgY2FjaGUgZGlyZWN0b3J5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q29tcGlsZUNhY2hlfSAgQSBjb25maWd1cmVkIENvbXBpbGVDYWNoZSBpbnN0YW5jZS5cclxuICAgKi8gICBcclxuICBzdGF0aWMgY3JlYXRlRnJvbUNvbXBpbGVyKGNhY2hlUGF0aCwgY29tcGlsZXIsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlPWZhbHNlKSB7XHJcbiAgICBsZXQgbmV3Q2FjaGVQYXRoID0gbnVsbDtcclxuICAgIGxldCBnZXRDYWNoZVBhdGggPSAoKSA9PiB7XHJcbiAgICAgIGlmIChuZXdDYWNoZVBhdGgpIHJldHVybiBuZXdDYWNoZVBhdGg7XHJcblxyXG4gICAgICBjb25zdCBkaWdlc3RPYmogPSB7XHJcbiAgICAgICAgbmFtZTogY29tcGlsZXIubmFtZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yLm5hbWUsXHJcbiAgICAgICAgdmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKCksXHJcbiAgICAgICAgb3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBuZXdDYWNoZVBhdGggPSBwYXRoLmpvaW4oY2FjaGVQYXRoLCBjcmVhdGVEaWdlc3RGb3JPYmplY3QoZGlnZXN0T2JqKSk7XHJcblxyXG4gICAgICBkKGBQYXRoIGZvciAke2RpZ2VzdE9iai5uYW1lfTogJHtuZXdDYWNoZVBhdGh9YCk7XHJcbiAgICAgIGQoYFNldCB1cCB3aXRoIHBhcmFtZXRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoZGlnZXN0T2JqKX1gKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcmVhZE9ubHlNb2RlKSBta2RpcnAuc3luYyhuZXdDYWNoZVBhdGgpO1xyXG4gICAgICByZXR1cm4gbmV3Q2FjaGVQYXRoO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgbGV0IHJldCA9IG5ldyBDb21waWxlQ2FjaGUoJycsIGZpbGVDaGFuZ2VDYWNoZSk7XHJcbiAgICByZXQuZ2V0Q2FjaGVQYXRoID0gZ2V0Q2FjaGVQYXRoO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuICBcclxuICAvKiogIFxyXG4gICAqIFJldHVybnMgYSBmaWxlJ3MgY29tcGlsZWQgY29udGVudHMgZnJvbSB0aGUgY2FjaGUuXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxlUGF0aCAgVGhlIHBhdGggdG8gdGhlIGZpbGUuIEZpbGVDaGFuZ2VkQ2FjaGUgd2lsbCBsb29rXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXAgdGhlIGhhc2ggYW5kIHVzZSB0aGF0IGFzIHRoZSBrZXkgaW4gdGhlIGNhY2hlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSAgQW4gb2JqZWN0IHdpdGggYWxsIGtpbmRzIG9mIGluZm9ybWF0aW9uXHJcbiAgICpcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSAgVGhlIHNvdXJjZSBjb2RlIGlmIHRoZSBmaWxlIHdhcyBhIHRleHQgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyfSBiaW5hcnlEYXRhICBUaGUgZmlsZSBpZiBpdCB3YXMgYSBiaW5hcnkgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSBzYXZlZCBpbiB0aGUgY2FjaGUuXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZGVwZW5kZW50RmlsZXMgIFRoZSBkZXBlbmRlbnQgZmlsZXMgcmV0dXJuZWQgZnJvbSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsaW5nIHRoZSBmaWxlLCBpZiBhbnkuXHJcbiAgICovICAgXHJcbiAgYXN5bmMgZ2V0KGZpbGVQYXRoKSB7XHJcbiAgICBkKGBGZXRjaGluZyAke2ZpbGVQYXRofSBmcm9tIGNhY2hlYCk7XHJcbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChwYXRoLnJlc29sdmUoZmlsZVBhdGgpKTtcclxuICBcclxuICAgIGxldCBjb2RlID0gbnVsbDtcclxuICAgIGxldCBtaW1lVHlwZSA9IG51bGw7XHJcbiAgICBsZXQgYmluYXJ5RGF0YSA9IG51bGw7XHJcbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBudWxsO1xyXG4gICAgXHJcbiAgICBsZXQgY2FjaGVGaWxlID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNhY2hlRmlsZSA9IHBhdGguam9pbih0aGlzLmdldENhY2hlUGF0aCgpLCBoYXNoSW5mby5oYXNoKTtcclxuICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XHJcbiAgICAgICAgZChcIkZpbGUgaXMgYmluYXJ5LCByZWFkaW5nIG91dCBpbmZvXCIpO1xyXG4gICAgICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwZnMucmVhZEZpbGUoY2FjaGVGaWxlICsgJy5pbmZvJykpO1xyXG4gICAgICAgIG1pbWVUeXBlID0gaW5mby5taW1lVHlwZTtcclxuICAgICAgICBkZXBlbmRlbnRGaWxlcyA9IGluZm8uZGVwZW5kZW50RmlsZXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYmluYXJ5RGF0YSA9IGhhc2hJbmZvLmJpbmFyeURhdGE7XHJcbiAgICAgICAgaWYgKCFiaW5hcnlEYXRhKSB7XHJcbiAgICAgICAgICBiaW5hcnlEYXRhID0gYXdhaXQgcGZzLnJlYWRGaWxlKGNhY2hlRmlsZSk7XHJcbiAgICAgICAgICBiaW5hcnlEYXRhID0gYXdhaXQgcHpsaWIuZ3VuemlwKGJpbmFyeURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGNhY2hlRmlsZSk7XHJcbiAgICAgICAgbGV0IHN0ciA9IChhd2FpdCBwemxpYi5ndW56aXAoYnVmKSkudG9TdHJpbmcoJ3V0ZjgnKTtcclxuXHJcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShzdHIpO1xyXG4gICAgICAgIGNvZGUgPSByZXN1bHQuY29kZTtcclxuICAgICAgICBtaW1lVHlwZSA9IHJlc3VsdC5taW1lVHlwZTtcclxuICAgICAgICBkZXBlbmRlbnRGaWxlcyA9IHJlc3VsdC5kZXBlbmRlbnRGaWxlcztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBkKGBGYWlsZWQgdG8gcmVhZCBjYWNoZSBmb3IgJHtmaWxlUGF0aH0sIGxvb2tlZCBpbiAke2NhY2hlRmlsZX06ICR7ZS5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4geyBoYXNoSW5mbywgY29kZSwgbWltZVR5cGUsIGJpbmFyeURhdGEsIGRlcGVuZGVudEZpbGVzIH07XHJcbiAgfVxyXG5cclxuICBcclxuICAvKiogIFxyXG4gICAqIFNhdmVzIGEgY29tcGlsZWQgcmVzdWx0IHRvIGNhY2hlXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBoYXNoSW5mbyAgVGhlIGhhc2ggaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aCAgIFxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nIC8gQnVmZmVyfSBjb2RlT3JCaW5hcnlEYXRhICAgVGhlIGZpbGUncyBjb250ZW50cywgZWl0aGVyIGFzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBzdHJpbmcgb3IgYSBCdWZmZXIuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSByZXR1cm5lZCBieSB0aGUgY29tcGlsZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gZGVwZW5kZW50RmlsZXMgIFRoZSBsaXN0IG9mIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBieVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNvbXBpbGVyLlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBDb21wbGV0aW9uLlxyXG4gICAqLyAgIFxyXG4gIGFzeW5jIHNhdmUoaGFzaEluZm8sIGNvZGVPckJpbmFyeURhdGEsIG1pbWVUeXBlLCBkZXBlbmRlbnRGaWxlcykge1xyXG4gICAgbGV0IGJ1ZiA9IG51bGw7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHRoaXMuZ2V0Q2FjaGVQYXRoKCksIGhhc2hJbmZvLmhhc2gpO1xyXG4gICAgZChgU2F2aW5nIHRvICR7dGFyZ2V0fWApO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XHJcbiAgICAgIGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAoY29kZU9yQmluYXJ5RGF0YSk7XHJcbiAgICAgIGF3YWl0IHBmcy53cml0ZUZpbGUodGFyZ2V0ICsgJy5pbmZvJywgSlNPTi5zdHJpbmdpZnkoe21pbWVUeXBlLCBkZXBlbmRlbnRGaWxlc30pLCAndXRmOCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnVmID0gYXdhaXQgcHpsaWIuZ3ppcChuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHtjb2RlOiBjb2RlT3JCaW5hcnlEYXRhLCBtaW1lVHlwZSwgZGVwZW5kZW50RmlsZXN9KSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKHRhcmdldCwgYnVmKTtcclxuICB9XHJcbiAgXHJcbiAgLyoqICBcclxuICAgKiBBdHRlbXB0cyB0byBmaXJzdCBnZXQgYSBrZXkgdmlhIHtAbGluayBnZXR9LCB0aGVuIGlmIGl0IGZhaWxzLCBjYWxsIGEgbWV0aG9kXHJcbiAgICogdG8gcmV0cmlldmUgdGhlIGNvbnRlbnRzLCB0aGVuIHNhdmUgdGhlIHJlc3VsdCB0byBjYWNoZS5cclxuICAgKiBcclxuICAgKiBUaGUgZmV0Y2hlciBwYXJhbWV0ZXIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2lnbmF0dXJlOlxyXG4gICAqIFxyXG4gICAqIFByb21pc2U8T2JqZWN0PiBmZXRjaGVyKGZpbGVQYXRoIDogc3RyaW5nLCBoYXNoSW5mbyA6IE9iamVjdCk7XHJcbiAgICogXHJcbiAgICogaGFzaEluZm8gaXMgYSB2YWx1ZSByZXR1cm5lZCBmcm9tIGdldEhhc2hGb3JQYXRoXHJcbiAgICogVGhlIHJldHVybiB2YWx1ZSBvZiBmZXRjaGVyIG11c3QgYmUgYW4gT2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXM6XHJcbiAgICogXHJcbiAgICogbWltZVR5cGUgLSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBkYXRhIHRvIHNhdmVcclxuICAgKiBjb2RlIChvcHRpb25hbCkgLSB0aGUgc291cmNlIGNvZGUgYXMgYSBzdHJpbmcsIGlmIGZpbGUgaXMgdGV4dFxyXG4gICAqIGJpbmFyeURhdGEgKG9wdGlvbmFsKSAtIHRoZSBmaWxlIGNvbnRlbnRzIGFzIGEgQnVmZmVyLCBpZiBmaWxlIGlzIGJpbmFyeVxyXG4gICAqIGRlcGVuZGVudEZpbGVzIC0gdGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBieSB0aGUgY29tcGlsZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVQYXRoICBUaGUgcGF0aCB0byB0aGUgZmlsZS4gRmlsZUNoYW5nZWRDYWNoZSB3aWxsIGxvb2tcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cCB0aGUgaGFzaCBhbmQgdXNlIHRoYXQgYXMgdGhlIGtleSBpbiB0aGUgY2FjaGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZmV0Y2hlciAgQSBtZXRob2Qgd2hpY2ggY29uZm9ybXMgdG8gdGhlIGRlc2NyaXB0aW9uIGFib3ZlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSAgQW4gT2JqZWN0IHdoaWNoIGhhcyB0aGUgc2FtZSBmaWVsZHMgYXMgdGhlIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBnZXR9IG1ldGhvZCByZXR1cm4gcmVzdWx0LlxyXG4gICAqLyAgIFxyXG4gIGFzeW5jIGdldE9yRmV0Y2goZmlsZVBhdGgsIGZldGNoZXIpIHtcclxuICAgIGxldCBjYWNoZVJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0KGZpbGVQYXRoKTtcclxuICAgIGlmIChjYWNoZVJlc3VsdC5jb2RlIHx8IGNhY2hlUmVzdWx0LmJpbmFyeURhdGEpIHJldHVybiBjYWNoZVJlc3VsdDtcclxuICAgIFxyXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoZXIoZmlsZVBhdGgsIGNhY2hlUmVzdWx0Lmhhc2hJbmZvKSB8fCB7IGhhc2hJbmZvOiBjYWNoZVJlc3VsdC5oYXNoSW5mbyB9O1xyXG4gICAgXHJcbiAgICBpZiAocmVzdWx0Lm1pbWVUeXBlICYmICFjYWNoZVJlc3VsdC5oYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcclxuICAgICAgZChgQ2FjaGUgbWlzczogc2F2aW5nIG91dCBpbmZvIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgICBhd2FpdCB0aGlzLnNhdmUoY2FjaGVSZXN1bHQuaGFzaEluZm8sIHJlc3VsdC5jb2RlIHx8IHJlc3VsdC5iaW5hcnlEYXRhLCByZXN1bHQubWltZVR5cGUsIHJlc3VsdC5kZXBlbmRlbnRGaWxlcyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlc3VsdC5oYXNoSW5mbyA9IGNhY2hlUmVzdWx0Lmhhc2hJbmZvO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgXHJcbiAgZ2V0U3luYyhmaWxlUGF0aCkge1xyXG4gICAgZChgRmV0Y2hpbmcgJHtmaWxlUGF0aH0gZnJvbSBjYWNoZWApO1xyXG4gICAgbGV0IGhhc2hJbmZvID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGhTeW5jKHBhdGgucmVzb2x2ZShmaWxlUGF0aCkpO1xyXG4gIFxyXG4gICAgbGV0IGNvZGUgPSBudWxsO1xyXG4gICAgbGV0IG1pbWVUeXBlID0gbnVsbDtcclxuICAgIGxldCBiaW5hcnlEYXRhID0gbnVsbDtcclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IG51bGw7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCBjYWNoZUZpbGUgPSBwYXRoLmpvaW4odGhpcy5nZXRDYWNoZVBhdGgoKSwgaGFzaEluZm8uaGFzaCk7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xyXG4gICAgICAgIGQoXCJGaWxlIGlzIGJpbmFyeSwgcmVhZGluZyBvdXQgaW5mb1wiKTtcclxuICAgICAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGNhY2hlRmlsZSArICcuaW5mbycpKTtcclxuICAgICAgICBtaW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XHJcbiAgICAgICAgZGVwZW5kZW50RmlsZXMgPSBpbmZvLmRlcGVuZGVudEZpbGVzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGJpbmFyeURhdGEgPSBoYXNoSW5mby5iaW5hcnlEYXRhO1xyXG4gICAgICAgIGlmICghYmluYXJ5RGF0YSkge1xyXG4gICAgICAgICAgYmluYXJ5RGF0YSA9IGZzLnJlYWRGaWxlU3luYyhjYWNoZUZpbGUpO1xyXG4gICAgICAgICAgYmluYXJ5RGF0YSA9IHpsaWIuZ3VuemlwU3luYyhiaW5hcnlEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyhjYWNoZUZpbGUpO1xyXG4gICAgICAgIGxldCBzdHIgPSAoemxpYi5ndW56aXBTeW5jKGJ1ZikpLnRvU3RyaW5nKCd1dGY4Jyk7XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2Uoc3RyKTtcclxuICAgICAgICBjb2RlID0gcmVzdWx0LmNvZGU7XHJcbiAgICAgICAgbWltZVR5cGUgPSByZXN1bHQubWltZVR5cGU7XHJcbiAgICAgICAgZGVwZW5kZW50RmlsZXMgPSByZXN1bHQuZGVwZW5kZW50RmlsZXM7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgZChgRmFpbGVkIHRvIHJlYWQgY2FjaGUgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7IGhhc2hJbmZvLCBjb2RlLCBtaW1lVHlwZSwgYmluYXJ5RGF0YSwgZGVwZW5kZW50RmlsZXMgfTtcclxuICB9XHJcblxyXG4gIHNhdmVTeW5jKGhhc2hJbmZvLCBjb2RlT3JCaW5hcnlEYXRhLCBtaW1lVHlwZSwgZGVwZW5kZW50RmlsZXMpIHtcclxuICAgIGxldCBidWYgPSBudWxsO1xyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLmdldENhY2hlUGF0aCgpLCBoYXNoSW5mby5oYXNoKTtcclxuICAgIGQoYFNhdmluZyB0byAke3RhcmdldH1gKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xyXG4gICAgICBidWYgPSB6bGliLmd6aXBTeW5jKGNvZGVPckJpbmFyeURhdGEpO1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCArICcuaW5mbycsIEpTT04uc3RyaW5naWZ5KHttaW1lVHlwZSwgZGVwZW5kZW50RmlsZXN9KSwgJ3V0ZjgnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh7Y29kZTogY29kZU9yQmluYXJ5RGF0YSwgbWltZVR5cGUsIGRlcGVuZGVudEZpbGVzfSkpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG4gIFxyXG4gIGdldE9yRmV0Y2hTeW5jKGZpbGVQYXRoLCBmZXRjaGVyKSB7XHJcbiAgICBsZXQgY2FjaGVSZXN1bHQgPSB0aGlzLmdldFN5bmMoZmlsZVBhdGgpO1xyXG4gICAgaWYgKGNhY2hlUmVzdWx0LmNvZGUgfHwgY2FjaGVSZXN1bHQuYmluYXJ5RGF0YSkgcmV0dXJuIGNhY2hlUmVzdWx0O1xyXG4gICAgXHJcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlcihmaWxlUGF0aCwgY2FjaGVSZXN1bHQuaGFzaEluZm8pIHx8IHsgaGFzaEluZm86IGNhY2hlUmVzdWx0Lmhhc2hJbmZvIH07XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQubWltZVR5cGUgJiYgIWNhY2hlUmVzdWx0Lmhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xyXG4gICAgICBkKGBDYWNoZSBtaXNzOiBzYXZpbmcgb3V0IGluZm8gZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHRoaXMuc2F2ZVN5bmMoY2FjaGVSZXN1bHQuaGFzaEluZm8sIHJlc3VsdC5jb2RlIHx8IHJlc3VsdC5iaW5hcnlEYXRhLCByZXN1bHQubWltZVR5cGUsIHJlc3VsdC5kZXBlbmRlbnRGaWxlcyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlc3VsdC5oYXNoSW5mbyA9IGNhY2hlUmVzdWx0Lmhhc2hJbmZvO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgXHJcbiAgXHJcbiAgLyoqICBcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgIFxyXG4gIGdldENhY2hlUGF0aCgpIHtcclxuICAgIC8vIE5COiBUaGlzIGlzIGFuIGV2aWwgaGFjayBzbyB0aGF0IGNyZWF0ZUZyb21Db21waWxlciBjYW4gc3RvbXAgaXRcclxuICAgIC8vIGF0IHdpbGxcclxuICAgIHJldHVybiB0aGlzLmNhY2hlUGF0aDtcclxuICB9XHJcbiAgICBcclxuICAgIFxyXG4gIC8qKiAgICBcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBmaWxlIHNob3VsZCBub3QgYmUgY29tcGlsZWQuIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgXHJcbiAgICogbmVjZXNzYXJpbHkgbWVhbiBpdCB3b24ndCBlbmQgdXAgaW4gdGhlIGNhY2hlLCBvbmx5IHRoYXQgaXRzIGNvbnRlbnRzIGFyZVxyXG4gICAqIHNhdmVkIHZlcmJhdGltIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmQgYW4gYXBwcm9wcmlhdGUgY29tcGlsZXIuXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBoYXNoSW5mbyAgVGhlIGhhc2ggaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aCAgIFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgYSBmaWxlIHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICovICAgXHJcbiAgc3RhdGljIHNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSB7XHJcbiAgICByZXR1cm4gaGFzaEluZm8uaXNNaW5pZmllZCB8fCBoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMgfHwgaGFzaEluZm8uaGFzU291cmNlTWFwIHx8IGhhc2hJbmZvLmlzRmlsZUJpbmFyeTtcclxuICB9XHJcbn1cclxuIl19