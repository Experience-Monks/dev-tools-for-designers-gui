'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;
exports.initializeRendererProcess = initializeRendererProcess;
exports.initializeProtocolHook = initializeProtocolHook;

require('./babel-maybefill');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

var magicWords = "__magic__file__to__help__electron__compile.js";
var magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';
var magicGlobalForAppRootDir = '__electron_compile_app_root_dir';

var d = require('debug')('electron-compile:protocol-hook');

var protocol = null;

/**
 * Adds our script header to the top of all HTML files
 *
 * @private
 */
function rigHtmlDocumentToInitializeElectronCompile(doc) {
  var lines = doc.split("\n");
  var replacement = '<head><script src="' + magicWords + '"></script>';
  var replacedHead = false;

  for (var i = 0; i < lines.length; i++) {
    if (!lines[i].match(/<head>/i)) continue;

    lines[i] = lines[i].replace(/<head>/i, replacement);
    replacedHead = true;
    break;
  }

  if (!replacedHead) {
    replacement = '<html$1><head><script src="' + magicWords + '"></script></head>';
    for (var i = 0; i < lines.length; i++) {
      if (!lines[i].match(/<html/i)) continue;

      lines[i] = lines[i].replace(/<html([^>]+)>/i, replacement);
      break;
    }
  }

  return lines.join("\n");
}

function requestFileJob(filePath, finish) {
  _fs2.default.readFile(filePath, function (err, buf) {
    if (err) {
      if (err.errno === 34) {
        finish(-6); // net::ERR_FILE_NOT_FOUND
        return;
      } else {
        finish(-2); // net::FAILED
        return;
      }
    }

    finish({
      data: buf,
      mimeType: _mimeTypes2.default.lookup(filePath) || 'text/plain'
    });
  });
}

var rendererInitialized = false;

/**
 * Called by our rigged script file at the top of every HTML file to set up
 * the same compilers as the browser process that created us
 *
 * @private
 */
function initializeRendererProcess(readOnlyMode) {
  if (rendererInitialized) return;

  // NB: If we don't do this, we'll get a renderer crash if you enable debug
  require('debug/browser');

  var rootCacheDir = require('remote').getGlobal(magicGlobalForRootCacheDir);
  var appRoot = require('remote').getGlobal(magicGlobalForAppRootDir);
  var compilerHost = null;

  // NB: This has to be synchronous because we need to block HTML parsing
  // until we're set up
  if (readOnlyMode) {
    d('Setting up electron-compile in precompiled mode with cache dir: ' + rootCacheDir);
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);
  } else {
    d('Setting up electron-compile in development mode with cache dir: ' + rootCacheDir);

    var _require = require('./config-parser');

    var createCompilers = _require.createCompilers;

    var compilersByMimeType = createCompilers();

    compilerHost = _compilerHost2.default.createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType);
  }

  require('./x-require');
  require('./require-hook').default(compilerHost);
  rendererInitialized = true;
}

/**
 * Initializes the protocol hook on file: that allows us to intercept files
 * loaded by Chromium and rewrite them. This method along with
 * {@link registerRequireExtension} are the top-level methods that electron-compile
 * actually uses to intercept code that Electron loads.
 *
 * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.
 */
function initializeProtocolHook(compilerHost) {
  protocol = protocol || require('protocol');

  global[magicGlobalForRootCacheDir] = compilerHost.rootCacheDir;
  global[magicGlobalForAppRootDir] = compilerHost.appRoot;

  var electronCompileSetupCode = 'if (window.require) require(\'electron-compile/lib/protocol-hook\').initializeRendererProcess(' + compilerHost.readOnlyMode + ');';

  protocol.interceptBufferProtocol('file', (function () {
    var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request, finish) {
      var uri, filePath, result, err;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              uri = _url2.default.parse(request.url);

              d('Intercepting url ' + request.url);

              if (!(request.url.indexOf(magicWords) > -1)) {
                _context.next = 5;
                break;
              }

              finish({
                mimeType: 'application/javascript',
                data: new Buffer(electronCompileSetupCode, 'utf8')
              });

              return _context.abrupt('return');

            case 5:

              // This is a protocol-relative URL that has gone pear-shaped in Electron,
              // let's rewrite it
              if (uri.host && uri.host.length > 1) {
                //let newUri = request.url.replace(/^file:/, "https:");
                // TODO: Jump off this bridge later
                d('TODO: Found bogus protocol-relative URL, can\'t fix it up!!');
                finish(-2);
              }

              filePath = decodeURIComponent(uri.pathname);

              // NB: pathname has a leading '/' on Win32 for some reason

              if (process.platform === 'win32') {
                filePath = filePath.slice(1);
              }

              // NB: Special-case files coming from atom.asar or node_modules

              if (!(filePath.match(/[\/\\]atom.asar/) || filePath.match(/[\/\\]node_modules/))) {
                _context.next = 11;
                break;
              }

              requestFileJob(filePath, finish);
              return _context.abrupt('return');

            case 11:
              _context.prev = 11;
              _context.next = 14;
              return compilerHost.compile(filePath);

            case 14:
              result = _context.sent;

              if (result.mimeType === 'text/html') {
                result.code = rigHtmlDocumentToInitializeElectronCompile(result.code);
              }

              if (!(result.binaryData || result.code instanceof Buffer)) {
                _context.next = 21;
                break;
              }

              finish({ data: result.binaryData || result.code, mimeType: result.mimeType });
              return _context.abrupt('return');

            case 21:
              finish({ data: new Buffer(result.code), mimeType: result.mimeType });
              return _context.abrupt('return');

            case 23:
              _context.next = 34;
              break;

            case 25:
              _context.prev = 25;
              _context.t0 = _context['catch'](11);
              err = 'Failed to compile ' + filePath + ': ' + _context.t0.message + '\n' + _context.t0.stack;

              d(err);

              if (!(_context.t0.errno === 34 /*ENOENT*/)) {
                _context.next = 32;
                break;
              }

              finish(-6); // net::ERR_FILE_NOT_FOUND
              return _context.abrupt('return');

            case 32:

              finish({ mimeType: 'text/plain', data: new Buffer(err) });
              return _context.abrupt('return');

            case 34:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this, [[11, 25]]);
    }));

    return function (_x, _x2) {
      return ref.apply(this, arguments);
    };
  })());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm90b2NvbC1ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O1FBb0JnQiwwQ0FBMEMsR0FBMUMsMENBQTBDO1FBcUQxQyx5QkFBeUIsR0FBekIseUJBQXlCO1FBcUN6QixzQkFBc0IsR0FBdEIsc0JBQXNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF2R3RDLElBQU0sVUFBVSxHQUFHLCtDQUErQyxDQUFDO0FBQ25FLElBQU0sMEJBQTBCLEdBQUcsbUNBQW1DLENBQUM7QUFDdkUsSUFBTSx3QkFBd0IsR0FBRyxpQ0FBaUMsQ0FBQzs7QUFFbkUsSUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7O0FBRTdELElBQUksUUFBUSxHQUFHLElBQUk7Ozs7Ozs7QUFBQyxBQU9iLFNBQVMsMENBQTBDLENBQUMsR0FBRyxFQUFFO0FBQzlELE1BQUksS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsTUFBSSxXQUFXLDJCQUF5QixVQUFVLGdCQUFhLENBQUM7QUFDaEUsTUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDOztBQUV6QixPQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNuQyxRQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxTQUFTOztBQUV6QyxTQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQUFBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUUsT0FBTyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUN0RCxnQkFBWSxHQUFHLElBQUksQ0FBQztBQUNwQixVQUFNO0dBQ1A7O0FBRUQsTUFBSSxDQUFDLFlBQVksRUFBRTtBQUNqQixlQUFXLG1DQUFpQyxVQUFVLHVCQUFvQixDQUFDO0FBQzNFLFNBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ25DLFVBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLFNBQVM7O0FBRXhDLFdBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxBQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBRSxPQUFPLENBQUMsZ0JBQWdCLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDN0QsWUFBTTtLQUNQO0dBQ0Y7O0FBRUQsU0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3pCOztBQUVELFNBQVMsY0FBYyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUU7QUFDeEMsZUFBRyxRQUFRLENBQUMsUUFBUSxFQUFFLFVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBSztBQUNsQyxRQUFJLEdBQUcsRUFBRTtBQUNQLFVBQUksR0FBRyxDQUFDLEtBQUssS0FBSyxFQUFFLEVBQUU7QUFDcEIsY0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQUMsQUFDWCxlQUFPO09BQ1IsTUFBTTtBQUNMLGNBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUFDLEFBQ1gsZUFBTztPQUNSO0tBQ0Y7O0FBRUQsVUFBTSxDQUFDO0FBQ0wsVUFBSSxFQUFFLEdBQUc7QUFDVCxjQUFRLEVBQUUsb0JBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLFlBQVk7S0FDaEQsQ0FBQyxDQUFDO0dBQ0osQ0FBQyxDQUFDO0NBQ0o7O0FBRUQsSUFBSSxtQkFBbUIsR0FBRyxLQUFLOzs7Ozs7OztBQUFDLEFBUXpCLFNBQVMseUJBQXlCLENBQUMsWUFBWSxFQUFFO0FBQ3RELE1BQUksbUJBQW1CLEVBQUUsT0FBTzs7O0FBQUEsQUFHaEMsU0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDOztBQUV6QixNQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLDBCQUEwQixDQUFDLENBQUM7QUFDM0UsTUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQ3BFLE1BQUksWUFBWSxHQUFHLElBQUk7Ozs7QUFBQyxBQUl4QixNQUFJLFlBQVksRUFBRTtBQUNoQixLQUFDLHNFQUFvRSxZQUFZLENBQUcsQ0FBQztBQUNyRixnQkFBWSxHQUFHLHVCQUFhLG1DQUFtQyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztHQUN4RixNQUFNO0FBQ0wsS0FBQyxzRUFBb0UsWUFBWSxDQUFHLENBQUM7O21CQUN6RCxPQUFPLENBQUMsaUJBQWlCLENBQUM7O1FBQTlDLGVBQWUsWUFBZixlQUFlOztBQUN2QixRQUFNLG1CQUFtQixHQUFHLGVBQWUsRUFBRSxDQUFDOztBQUU5QyxnQkFBWSxHQUFHLHVCQUFhLDJCQUEyQixDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztHQUNyRzs7QUFFRCxTQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkIsU0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2hELHFCQUFtQixHQUFHLElBQUksQ0FBQztDQUM1Qjs7Ozs7Ozs7OztBQUFBLEFBV00sU0FBUyxzQkFBc0IsQ0FBQyxZQUFZLEVBQUU7QUFDbkQsVUFBUSxHQUFHLFFBQVEsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7O0FBRTNDLFFBQU0sQ0FBQywwQkFBMEIsQ0FBQyxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUM7QUFDL0QsUUFBTSxDQUFDLHdCQUF3QixDQUFDLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQzs7QUFFeEQsTUFBTSx3QkFBd0Isc0dBQWtHLFlBQVksQ0FBQyxZQUFZLE9BQUksQ0FBQzs7QUFFOUosVUFBUSxDQUFDLHVCQUF1QixDQUFDLE1BQU07d0RBQUUsaUJBQWUsT0FBTyxFQUFFLE1BQU07VUFDakUsR0FBRyxFQXFCSCxRQUFRLEVBY04sTUFBTSxFQWNOLEdBQUc7Ozs7O0FBakRMLGlCQUFHLEdBQUcsY0FBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQzs7QUFFaEMsZUFBQyx1QkFBcUIsT0FBTyxDQUFDLEdBQUcsQ0FBRyxDQUFDOztvQkFDakMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7Ozs7O0FBQ3RDLG9CQUFNLENBQUM7QUFDTCx3QkFBUSxFQUFFLHdCQUF3QjtBQUNsQyxvQkFBSSxFQUFFLElBQUksTUFBTSxDQUFDLHdCQUF3QixFQUFFLE1BQU0sQ0FBQztlQUNuRCxDQUFDLENBQUM7Ozs7Ozs7O0FBT0wsa0JBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7OztBQUduQyxpQkFBQywrREFBOEQsQ0FBQztBQUNoRSxzQkFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7ZUFDWjs7QUFFRyxzQkFBUSxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7Ozs7QUFHL0Msa0JBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7QUFDaEMsd0JBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2VBQzlCOzs7QUFBQTtvQkFHRyxRQUFRLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFBOzs7OztBQUMzRSw0QkFBYyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQzs7Ozs7O3FCQUtkLFlBQVksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDOzs7QUFBN0Msb0JBQU07O0FBRVYsa0JBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxXQUFXLEVBQUU7QUFDbkMsc0JBQU0sQ0FBQyxJQUFJLEdBQUcsMENBQTBDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2VBQ3ZFOztvQkFFRyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxJQUFJLFlBQVksTUFBTSxDQUFBOzs7OztBQUNwRCxvQkFBTSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxVQUFVLElBQUksTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7Ozs7QUFHOUUsb0JBQU0sQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBSW5FLGlCQUFHLDBCQUF3QixRQUFRLFVBQUssWUFBRSxPQUFPLFVBQUssWUFBRSxLQUFLOztBQUNqRSxlQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7O29CQUVILFlBQUUsS0FBSyxLQUFLLEVBQUUsWUFBQTs7Ozs7QUFDaEIsb0JBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUFDOzs7O0FBSWIsb0JBQU0sQ0FBQyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Ozs7Ozs7O0tBRzdEOzs7OztPQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJwcm90b2NvbC1ob29rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2JhYmVsLW1heWJlZmlsbCc7XHJcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IG1pbWUgZnJvbSAnbWltZS10eXBlcyc7XHJcblxyXG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XHJcblxyXG5jb25zdCBtYWdpY1dvcmRzID0gXCJfX21hZ2ljX19maWxlX190b19faGVscF9fZWxlY3Ryb25fX2NvbXBpbGUuanNcIjtcclxuY29uc3QgbWFnaWNHbG9iYWxGb3JSb290Q2FjaGVEaXIgPSAnX19lbGVjdHJvbl9jb21waWxlX3Jvb3RfY2FjaGVfZGlyJztcclxuY29uc3QgbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9hcHBfcm9vdF9kaXInO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6cHJvdG9jb2wtaG9vaycpO1xyXG5cclxubGV0IHByb3RvY29sID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIG91ciBzY3JpcHQgaGVhZGVyIHRvIHRoZSB0b3Agb2YgYWxsIEhUTUwgZmlsZXNcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByaWdIdG1sRG9jdW1lbnRUb0luaXRpYWxpemVFbGVjdHJvbkNvbXBpbGUoZG9jKSB7XHJcbiAgbGV0IGxpbmVzID0gZG9jLnNwbGl0KFwiXFxuXCIpO1xyXG4gIGxldCByZXBsYWNlbWVudCA9IGA8aGVhZD48c2NyaXB0IHNyYz1cIiR7bWFnaWNXb3Jkc31cIj48L3NjcmlwdD5gO1xyXG4gIGxldCByZXBsYWNlZEhlYWQgPSBmYWxzZTtcclxuXHJcbiAgZm9yIChsZXQgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghbGluZXNbaV0ubWF0Y2goLzxoZWFkPi9pKSkgY29udGludWU7XHJcblxyXG4gICAgbGluZXNbaV0gPSAobGluZXNbaV0pLnJlcGxhY2UoLzxoZWFkPi9pLCByZXBsYWNlbWVudCk7XHJcbiAgICByZXBsYWNlZEhlYWQgPSB0cnVlO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICBpZiAoIXJlcGxhY2VkSGVhZCkge1xyXG4gICAgcmVwbGFjZW1lbnQgPSBgPGh0bWwkMT48aGVhZD48c2NyaXB0IHNyYz1cIiR7bWFnaWNXb3Jkc31cIj48L3NjcmlwdD48L2hlYWQ+YDtcclxuICAgIGZvciAobGV0IGk9MDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghbGluZXNbaV0ubWF0Y2goLzxodG1sL2kpKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGxpbmVzW2ldID0gKGxpbmVzW2ldKS5yZXBsYWNlKC88aHRtbChbXj5dKyk+L2ksIHJlcGxhY2VtZW50KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWVzdEZpbGVKb2IoZmlsZVBhdGgsIGZpbmlzaCkge1xyXG4gIGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAoZXJyLCBidWYpID0+IHtcclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgaWYgKGVyci5lcnJubyA9PT0gMzQpIHtcclxuICAgICAgICBmaW5pc2goLTYpOyAvLyBuZXQ6OkVSUl9GSUxFX05PVF9GT1VORFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmaW5pc2goLTIpOyAvLyBuZXQ6OkZBSUxFRFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpbmlzaCh7XHJcbiAgICAgIGRhdGE6IGJ1ZixcclxuICAgICAgbWltZVR5cGU6IG1pbWUubG9va3VwKGZpbGVQYXRoKSB8fCAndGV4dC9wbGFpbidcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5sZXQgcmVuZGVyZXJJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCBieSBvdXIgcmlnZ2VkIHNjcmlwdCBmaWxlIGF0IHRoZSB0b3Agb2YgZXZlcnkgSFRNTCBmaWxlIHRvIHNldCB1cFxyXG4gKiB0aGUgc2FtZSBjb21waWxlcnMgYXMgdGhlIGJyb3dzZXIgcHJvY2VzcyB0aGF0IGNyZWF0ZWQgdXNcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplUmVuZGVyZXJQcm9jZXNzKHJlYWRPbmx5TW9kZSkge1xyXG4gIGlmIChyZW5kZXJlckluaXRpYWxpemVkKSByZXR1cm47XHJcblxyXG4gIC8vIE5COiBJZiB3ZSBkb24ndCBkbyB0aGlzLCB3ZSdsbCBnZXQgYSByZW5kZXJlciBjcmFzaCBpZiB5b3UgZW5hYmxlIGRlYnVnXHJcbiAgcmVxdWlyZSgnZGVidWcvYnJvd3NlcicpO1xyXG5cclxuICBsZXQgcm9vdENhY2hlRGlyID0gcmVxdWlyZSgncmVtb3RlJykuZ2V0R2xvYmFsKG1hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyKTtcclxuICBsZXQgYXBwUm9vdCA9IHJlcXVpcmUoJ3JlbW90ZScpLmdldEdsb2JhbChtYWdpY0dsb2JhbEZvckFwcFJvb3REaXIpO1xyXG4gIGxldCBjb21waWxlckhvc3QgPSBudWxsO1xyXG5cclxuICAvLyBOQjogVGhpcyBoYXMgdG8gYmUgc3luY2hyb25vdXMgYmVjYXVzZSB3ZSBuZWVkIHRvIGJsb2NrIEhUTUwgcGFyc2luZ1xyXG4gIC8vIHVudGlsIHdlJ3JlIHNldCB1cFxyXG4gIGlmIChyZWFkT25seU1vZGUpIHtcclxuICAgIGQoYFNldHRpbmcgdXAgZWxlY3Ryb24tY29tcGlsZSBpbiBwcmVjb21waWxlZCBtb2RlIHdpdGggY2FjaGUgZGlyOiAke3Jvb3RDYWNoZURpcn1gKTtcclxuICAgIGNvbXBpbGVySG9zdCA9IENvbXBpbGVySG9zdC5jcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkKGBTZXR0aW5nIHVwIGVsZWN0cm9uLWNvbXBpbGUgaW4gZGV2ZWxvcG1lbnQgbW9kZSB3aXRoIGNhY2hlIGRpcjogJHtyb290Q2FjaGVEaXJ9YCk7XHJcbiAgICBjb25zdCB7IGNyZWF0ZUNvbXBpbGVycyB9ID0gcmVxdWlyZSgnLi9jb25maWctcGFyc2VyJyk7XHJcbiAgICBjb25zdCBjb21waWxlcnNCeU1pbWVUeXBlID0gY3JlYXRlQ29tcGlsZXJzKCk7XHJcblxyXG4gICAgY29tcGlsZXJIb3N0ID0gQ29tcGlsZXJIb3N0LmNyZWF0ZUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGNvbXBpbGVyc0J5TWltZVR5cGUpO1xyXG4gIH1cclxuXHJcbiAgcmVxdWlyZSgnLi94LXJlcXVpcmUnKTtcclxuICByZXF1aXJlKCcuL3JlcXVpcmUtaG9vaycpLmRlZmF1bHQoY29tcGlsZXJIb3N0KTtcclxuICByZW5kZXJlckluaXRpYWxpemVkID0gdHJ1ZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyB0aGUgcHJvdG9jb2wgaG9vayBvbiBmaWxlOiB0aGF0IGFsbG93cyB1cyB0byBpbnRlcmNlcHQgZmlsZXNcclxuICogbG9hZGVkIGJ5IENocm9taXVtIGFuZCByZXdyaXRlIHRoZW0uIFRoaXMgbWV0aG9kIGFsb25nIHdpdGhcclxuICoge0BsaW5rIHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbn0gYXJlIHRoZSB0b3AtbGV2ZWwgbWV0aG9kcyB0aGF0IGVsZWN0cm9uLWNvbXBpbGVcclxuICogYWN0dWFsbHkgdXNlcyB0byBpbnRlcmNlcHQgY29kZSB0aGF0IEVsZWN0cm9uIGxvYWRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtDb21waWxlckhvc3R9IGNvbXBpbGVySG9zdCAgVGhlIGNvbXBpbGVyIGhvc3QgdG8gdXNlIGZvciBjb21waWxhdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplUHJvdG9jb2xIb29rKGNvbXBpbGVySG9zdCkge1xyXG4gIHByb3RvY29sID0gcHJvdG9jb2wgfHwgcmVxdWlyZSgncHJvdG9jb2wnKTtcclxuXHJcbiAgZ2xvYmFsW21hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyXSA9IGNvbXBpbGVySG9zdC5yb290Q2FjaGVEaXI7XHJcbiAgZ2xvYmFsW21hZ2ljR2xvYmFsRm9yQXBwUm9vdERpcl0gPSBjb21waWxlckhvc3QuYXBwUm9vdDtcclxuXHJcbiAgY29uc3QgZWxlY3Ryb25Db21waWxlU2V0dXBDb2RlID0gYGlmICh3aW5kb3cucmVxdWlyZSkgcmVxdWlyZSgnZWxlY3Ryb24tY29tcGlsZS9saWIvcHJvdG9jb2wtaG9vaycpLmluaXRpYWxpemVSZW5kZXJlclByb2Nlc3MoJHtjb21waWxlckhvc3QucmVhZE9ubHlNb2RlfSk7YDtcclxuXHJcbiAgcHJvdG9jb2wuaW50ZXJjZXB0QnVmZmVyUHJvdG9jb2woJ2ZpbGUnLCBhc3luYyBmdW5jdGlvbihyZXF1ZXN0LCBmaW5pc2gpIHtcclxuICAgIGxldCB1cmkgPSB1cmwucGFyc2UocmVxdWVzdC51cmwpO1xyXG5cclxuICAgIGQoYEludGVyY2VwdGluZyB1cmwgJHtyZXF1ZXN0LnVybH1gKTtcclxuICAgIGlmIChyZXF1ZXN0LnVybC5pbmRleE9mKG1hZ2ljV29yZHMpID4gLTEpIHtcclxuICAgICAgZmluaXNoKHtcclxuICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGRhdGE6IG5ldyBCdWZmZXIoZWxlY3Ryb25Db21waWxlU2V0dXBDb2RlLCAndXRmOCcpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgaXMgYSBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgdGhhdCBoYXMgZ29uZSBwZWFyLXNoYXBlZCBpbiBFbGVjdHJvbixcclxuICAgIC8vIGxldCdzIHJld3JpdGUgaXRcclxuICAgIGlmICh1cmkuaG9zdCAmJiB1cmkuaG9zdC5sZW5ndGggPiAxKSB7XHJcbiAgICAgIC8vbGV0IG5ld1VyaSA9IHJlcXVlc3QudXJsLnJlcGxhY2UoL15maWxlOi8sIFwiaHR0cHM6XCIpO1xyXG4gICAgICAvLyBUT0RPOiBKdW1wIG9mZiB0aGlzIGJyaWRnZSBsYXRlclxyXG4gICAgICBkKGBUT0RPOiBGb3VuZCBib2d1cyBwcm90b2NvbC1yZWxhdGl2ZSBVUkwsIGNhbid0IGZpeCBpdCB1cCEhYCk7XHJcbiAgICAgIGZpbmlzaCgtMik7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpbGVQYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaS5wYXRobmFtZSk7XHJcblxyXG4gICAgLy8gTkI6IHBhdGhuYW1lIGhhcyBhIGxlYWRpbmcgJy8nIG9uIFdpbjMyIGZvciBzb21lIHJlYXNvblxyXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcclxuICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgxKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOQjogU3BlY2lhbC1jYXNlIGZpbGVzIGNvbWluZyBmcm9tIGF0b20uYXNhciBvciBub2RlX21vZHVsZXNcclxuICAgIGlmIChmaWxlUGF0aC5tYXRjaCgvW1xcL1xcXFxdYXRvbS5hc2FyLykgfHwgZmlsZVBhdGgubWF0Y2goL1tcXC9cXFxcXW5vZGVfbW9kdWxlcy8pKSB7XHJcbiAgICAgIHJlcXVlc3RGaWxlSm9iKGZpbGVQYXRoLCBmaW5pc2gpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVySG9zdC5jb21waWxlKGZpbGVQYXRoKTtcclxuXHJcbiAgICAgIGlmIChyZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L2h0bWwnKSB7XHJcbiAgICAgICAgcmVzdWx0LmNvZGUgPSByaWdIdG1sRG9jdW1lbnRUb0luaXRpYWxpemVFbGVjdHJvbkNvbXBpbGUocmVzdWx0LmNvZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzdWx0LmJpbmFyeURhdGEgfHwgcmVzdWx0LmNvZGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcclxuICAgICAgICBmaW5pc2goeyBkYXRhOiByZXN1bHQuYmluYXJ5RGF0YSB8fCByZXN1bHQuY29kZSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmluaXNoKHsgZGF0YTogbmV3IEJ1ZmZlcihyZXN1bHQuY29kZSksIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGxldCBlcnIgPSBgRmFpbGVkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH06ICR7ZS5tZXNzYWdlfVxcbiR7ZS5zdGFja31gO1xyXG4gICAgICBkKGVycik7XHJcblxyXG4gICAgICBpZiAoZS5lcnJubyA9PT0gMzQgLypFTk9FTlQqLykge1xyXG4gICAgICAgIGZpbmlzaCgtNik7IC8vIG5ldDo6RVJSX0ZJTEVfTk9UX0ZPVU5EXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmaW5pc2goeyBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLCBkYXRhOiBuZXcgQnVmZmVyKGVycikgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG4iXX0=