'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCompilerHostFromProjectRoot = exports.createCompilerHostFromConfigFile = exports.createCompilerHostFromBabelRc = undefined;
exports.initializeGlobalHooks = initializeGlobalHooks;
exports.init = init;
exports.createCompilerHostFromConfiguration = createCompilerHostFromConfiguration;
exports.createCompilerHostFromBabelRcSync = createCompilerHostFromBabelRcSync;
exports.createCompilerHostFromConfigFileSync = createCompilerHostFromConfigFileSync;
exports.createCompilerHostFromProjectRootSync = createCompilerHostFromProjectRootSync;
exports.calculateDefaultCompileCacheDirectory = calculateDefaultCompileCacheDirectory;
exports.getDefaultConfiguration = getDefaultConfiguration;
exports.createCompilers = createCompilers;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _promise = require('./promise');

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

var _protocolHook = require('./protocol-hook');

var _requireHook = require('./require-hook');

var _requireHook2 = _interopRequireDefault(_requireHook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

var d = require('debug')('electron-compile:config-parser');

// NB: We intentionally delay-load this so that in production, you can create
// cache-only versions of these compilers
var allCompilerClasses = null;

function statSyncNoException(fsPath) {
  if ('statSyncNoException' in _fs2.default) {
    return _fs2.default.statSyncNoException(fsPath);
  }

  try {
    return _fs2.default.statSync(fsPath);
  } catch (e) {
    return null;
  }
}

/**
 * Initialize the global hooks (protocol hook for file:, node.js hook) 
 * independent of initializing the compiler. This method is usually called by
 * init instead of directly
 * 
 * @param {CompilerHost} compilerHost  The compiler host to use.
 *  
 */
function initializeGlobalHooks(compilerHost) {
  var globalVar = global || window;
  globalVar.globalCompilerHost = compilerHost;

  (0, _requireHook2.default)(compilerHost);

  if ('type' in process && process.type === 'browser') {
    var _require = require('electron');

    var app = _require.app;

    var protoify = function protoify() {
      (0, _protocolHook.initializeProtocolHook)(compilerHost);
    };
    if (app.isReady()) {
      protoify();
    } else {
      app.on('ready', protoify);
    }
  }
}

/**
 * Initialize electron-compile and set it up, either for development or 
 * production use. This is almost always the only method you need to use in order
 * to use electron-compile.
 *  
 * @param  {string} appRoot  The top-level directory for your application (i.e.
 *                           the one which has your package.json).
 *
 * @param  {string} mainModule  The module to require in, relative to the module
 *                              calling init, that will start your app. Write this 
 *                              as if you were writing a require call from here.
 *
 * @param  {bool} productionMode   If explicitly True/False, will set read-only
 *                                 mode to be disabled/enabled. If not, we'll
 *                                 guess based on the presence of a production
 *                                 cache.
 */
function init(appRoot, mainModule) {
  var productionMode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var compilerHost = null;
  var cacheDir = _path2.default.join(appRoot, '.cache');

  if (productionMode === null) {
    productionMode = !!statSyncNoException(cacheDir);
  }

  if (productionMode) {
    // In read-only mode, we'll assume that everything is in `appRoot/.cache`
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(cacheDir, appRoot);
  } else {
    compilerHost = createCompilerHostFromProjectRootSync(appRoot);
  }

  initializeGlobalHooks(compilerHost);
  require.main.require(mainModule);
}

/**
 * Creates a {@link CompilerHost} with the given information. This method is
 * usually called by {@link createCompilerHostFromProjectRoot}.
 *  
 * @private
 */
function createCompilerHostFromConfiguration(info) {
  var compilers = createCompilers();
  var rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();

  d('Creating CompilerHost: ' + JSON.stringify(info) + ', rootCacheDir = ' + rootCacheDir);
  var fileChangeCache = new _fileChangeCache2.default(info.appRoot);
  var ret = new _compilerHost2.default(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain']);

  _lodash2.default.each(Object.keys(info.options || {}), function (x) {
    var opts = info.options[x];
    if (!(x in compilers)) {
      throw new Error('Found compiler settings for missing compiler: ' + x);
    }

    d('Setting options for ' + x + ': ' + JSON.stringify(opts));
    compilers[x].compilerOptions = opts;
  });

  // NB: It's super important that we guarantee that the configuration is saved
  // out, because we'll need to re-read it in the renderer process
  d('Created compiler host with options: ' + JSON.stringify(info));
  ret.saveConfigurationSync();
  return ret;
}

/**
 * Creates a compiler host from a .babelrc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *  
 * @param  {string} file  The path to a .babelrc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromBabelRc = exports.createCompilerHostFromBabelRc = (function () {
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(file) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var info, ourEnv;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = JSON;
            _context.next = 3;
            return _promise.pfs.readFile(file, 'utf8');

          case 3:
            _context.t1 = _context.sent;
            info = _context.t0.parse.call(_context.t0, _context.t1);

            // package.json
            if ('babel' in info) {
              info = info.babel;
            }

            if ('env' in info) {
              ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';

              info = info.env[ourEnv];
            }

            // Are we still package.json (i.e. is there no babel info whatsoever?)

            if (!('name' in info && 'version' in info)) {
              _context.next = 9;
              break;
            }

            return _context.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: getDefaultConfiguration(),
              rootCacheDir: rootCacheDir
            }));

          case 9:
            return _context.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: {
                'application/javascript': info
              },
              rootCacheDir: rootCacheDir
            }));

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function createCompilerHostFromBabelRc(_x3) {
    return ref.apply(this, arguments);
  };
})();

/**
 * Creates a compiler host from a .compilerc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *  
 * @param  {string} file  The path to a .compilerc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromConfigFile = exports.createCompilerHostFromConfigFile = (function () {
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(file) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    var info, _ourEnv;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = JSON;
            _context2.next = 3;
            return _promise.pfs.readFile(file, 'utf8');

          case 3:
            _context2.t1 = _context2.sent;
            info = _context2.t0.parse.call(_context2.t0, _context2.t1);

            if ('env' in info) {
              _ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';

              info = info.env[_ourEnv];
            }

            return _context2.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: info,
              rootCacheDir: rootCacheDir
            }));

          case 7:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function createCompilerHostFromConfigFile(_x5) {
    return ref.apply(this, arguments);
  };
})();

/**
 * Creates a configured {@link CompilerHost} instance from the project root 
 * directory. This method first searches for a .compilerc, then falls back to the
 * default locations for Babel configuration info. If neither are found, defaults
 * to standard settings
 *  
 * @param  {string} rootDir  The root application directory (i.e. the directory
 *                           that has the app's package.json)
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromProjectRoot = exports.createCompilerHostFromProjectRoot = (function () {
  var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(rootDir) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var compilerc, babelrc;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            compilerc = _path2.default.join(rootDir, '.compilerc');

            if (!statSyncNoException(compilerc)) {
              _context3.next = 6;
              break;
            }

            d('Found a .compilerc at ' + compilerc + ', using it');
            _context3.next = 5;
            return createCompilerHostFromConfigFile(compilerc, rootCacheDir);

          case 5:
            return _context3.abrupt('return', _context3.sent);

          case 6:
            babelrc = _path2.default.join(rootDir, '.babelrc');

            if (!statSyncNoException(babelrc)) {
              _context3.next = 12;
              break;
            }

            d('Found a .babelrc at ' + babelrc + ', using it');
            _context3.next = 11;
            return createCompilerHostFromBabelRc(babelrc, rootCacheDir);

          case 11:
            return _context3.abrupt('return', _context3.sent);

          case 12:

            d('Using package.json or default parameters at ' + rootDir);
            _context3.next = 15;
            return createCompilerHostFromBabelRc(_path2.default.join(rootDir, 'package.json'), rootCacheDir);

          case 15:
            return _context3.abrupt('return', _context3.sent);

          case 16:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function createCompilerHostFromProjectRoot(_x7) {
    return ref.apply(this, arguments);
  };
})();

function createCompilerHostFromBabelRcSync(file) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  // package.json
  if ('babel' in info) {
    info = info.babel;
  }

  if ('env' in info) {
    var _ourEnv2 = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';
    info = info.env[_ourEnv2];
  }

  // Are we still package.json (i.e. is there no babel info whatsoever?)
  if ('name' in info && 'version' in info) {
    return createCompilerHostFromConfiguration({
      appRoot: _path2.default.dirname(file),
      options: getDefaultConfiguration(),
      rootCacheDir: rootCacheDir
    });
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: {
      'application/javascript': info
    },
    rootCacheDir: rootCacheDir
  });
}

function createCompilerHostFromConfigFileSync(file) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  if ('env' in info) {
    var _ourEnv3 = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';
    info = info.env[_ourEnv3];
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: info,
    rootCacheDir: rootCacheDir
  });
}

function createCompilerHostFromProjectRootSync(rootDir) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var compilerc = _path2.default.join(rootDir, '.compilerc');
  if (statSyncNoException(compilerc)) {
    d('Found a .compilerc at ' + compilerc + ', using it');
    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir);
  }

  var babelrc = _path2.default.join(rootDir, '.babelrc');
  if (statSyncNoException(babelrc)) {
    d('Found a .babelrc at ' + babelrc + ', using it');
    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir);
  }

  d('Using package.json or default parameters at ' + rootDir);
  return createCompilerHostFromBabelRcSync(_path2.default.join(rootDir, 'package.json'), rootCacheDir);
}

/**
 * Returns what electron-compile would use as a default rootCacheDir. Usually only
 * used for debugging purposes
 *  
 * @return {string}  A path that may or may not exist where electron-compile would
 *                   set up a development mode cache.
 */
function calculateDefaultCompileCacheDirectory() {
  var tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';
  var hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');

  var cacheDir = _path2.default.join(tmpDir, 'compileCache_' + hash);
  _mkdirp2.default.sync(cacheDir);

  d('Using default cache directory: ' + cacheDir);
  return cacheDir;
}

/**
 * Returns the default .configrc if no configuration information can be found.
 *  
 * @return {Object}  A list of default config settings for electron-compiler.
 */
function getDefaultConfiguration() {
  return {
    'application/javascript': {
      "presets": ["stage-0", "es2015", "react"],
      "sourceMaps": "inline"
    }
  };
}

/**
 * Allows you to create new instances of all compilers that are supported by 
 * electron-compile and use them directly. Currently supports Babel, CoffeeScript, 
 * TypeScript, LESS, and Jade.
 *  
 * @return {Object}  An Object whose Keys are MIME types, and whose values 
 * are instances of @{link CompilerBase}.
 */
function createCompilers() {
  if (!allCompilerClasses) {
    // First we want to see if electron-compilers itself has been installed with
    // devDependencies. If that's not the case, check to see if
    // electron-compilers is installed as a peer dependency (probably as a
    // devDependency of the root project).
    var locations = ['electron-compilers', '../../electron-compilers'];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var location = _step.value;

        try {
          allCompilerClasses = require(location);
        } catch (e) {
          // Yolo
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!allCompilerClasses) {
      throw new Error("Electron compilers not found but were requested to be loaded");
    }
  }

  // NB: Note that this code is carefully set up so that InlineHtmlCompiler
  // (i.e. classes with `createFromCompilers`) initially get an empty object,
  // but will have a reference to the final result of what we return, which
  // resolves the circular dependency we'd otherwise have here.
  var ret = {};
  var instantiatedClasses = _lodash2.default.map(allCompilerClasses, function (Klass) {
    if ('createFromCompilers' in Klass) {
      return Klass.createFromCompilers(ret);
    } else {
      return new Klass();
    }
  });

  _lodash2.default.reduce(instantiatedClasses, function (acc, x) {
    var Klass = Object.getPrototypeOf(x).constructor;

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = Klass.getInputMimeTypes()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var type = _step2.value;
        acc[type] = x;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return acc;
  }, ret);

  return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctcGFyc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztRQXNDZ0IscUJBQXFCLEdBQXJCLHFCQUFxQjtRQW9DckIsSUFBSSxHQUFKLElBQUk7UUEwQkosbUNBQW1DLEdBQW5DLG1DQUFtQztRQTJIbkMsaUNBQWlDLEdBQWpDLGlDQUFpQztRQStCakMsb0NBQW9DLEdBQXBDLG9DQUFvQztRQWVwQyxxQ0FBcUMsR0FBckMscUNBQXFDO1FBd0JyQyxxQ0FBcUMsR0FBckMscUNBQXFDO1FBaUJyQyx1QkFBdUIsR0FBdkIsdUJBQXVCO1FBaUJ2QixlQUFlLEdBQWYsZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1VC9CLElBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxnQ0FBZ0MsQ0FBQzs7OztBQUFDLEFBSTdELElBQUksa0JBQWtCLEdBQUcsSUFBSSxDQUFDOztBQUU5QixTQUFTLG1CQUFtQixDQUFDLE1BQU0sRUFBRTtBQUNuQyxNQUFJLHFCQUFxQixnQkFBTSxFQUFFO0FBQy9CLFdBQU8sYUFBRyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUN2Qzs7QUFFRCxNQUFJO0FBQ0YsV0FBTyxhQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUM1QixDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsV0FBTyxJQUFJLENBQUM7R0FDYjtDQUNGOzs7Ozs7Ozs7O0FBQUEsQUFXTSxTQUFTLHFCQUFxQixDQUFDLFlBQVksRUFBRTtBQUNsRCxNQUFJLFNBQVMsR0FBSSxNQUFNLElBQUksTUFBTSxBQUFDLENBQUM7QUFDbkMsV0FBUyxDQUFDLGtCQUFrQixHQUFHLFlBQVksQ0FBQzs7QUFFNUMsNkJBQXlCLFlBQVksQ0FBQyxDQUFDOztBQUV2QyxNQUFJLE1BQU0sSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUU7bUJBQ25DLE9BQU8s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QUFJLEtBQUssRUFBRSxDQUFDO0tBQ3BCO0dBQ0YsQ0FBQyxDQUFDOztBQUVILG1CQUFFLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxVQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUs7QUFDdkMsUUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7Ozs7Ozs7QUFFakQsNEJBQWlCLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxtSUFBRTtZQUFuQyxJQUFJO0FBQWlDLFdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7T0FBRTs7Ozs7Ozs7Ozs7Ozs7OztBQUM5RCxXQUFPLEdBQUcsQ0FBQztHQUNaLEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRVIsU0FBTyxHQUFHLENBQUM7Q0FDWiIsImZpbGUiOiJjb25maWctcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJztcclxuaW1wb3J0IHtwZnN9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5pbXBvcnQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICcuL2ZpbGUtY2hhbmdlLWNhY2hlJztcclxuaW1wb3J0IENvbXBpbGVySG9zdCBmcm9tICcuL2NvbXBpbGVyLWhvc3QnO1xyXG5pbXBvcnQgeyBpbml0aWFsaXplUHJvdG9jb2xIb29rIH0gZnJvbSAnLi9wcm90b2NvbC1ob29rJztcclxuaW1wb3J0IHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbiBmcm9tICcuL3JlcXVpcmUtaG9vayc7XHJcblxyXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpjb25maWctcGFyc2VyJyk7XHJcblxyXG4vLyBOQjogV2UgaW50ZW50aW9uYWxseSBkZWxheS1sb2FkIHRoaXMgc28gdGhhdCBpbiBwcm9kdWN0aW9uLCB5b3UgY2FuIGNyZWF0ZVxyXG4vLyBjYWNoZS1vbmx5IHZlcnNpb25zIG9mIHRoZXNlIGNvbXBpbGVyc1xyXG5sZXQgYWxsQ29tcGlsZXJDbGFzc2VzID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIHN0YXRTeW5jTm9FeGNlcHRpb24oZnNQYXRoKSB7XHJcbiAgaWYgKCdzdGF0U3luY05vRXhjZXB0aW9uJyBpbiBmcykge1xyXG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jTm9FeGNlcHRpb24oZnNQYXRoKTtcclxuICB9XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBmcy5zdGF0U3luYyhmc1BhdGgpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIHRoZSBnbG9iYWwgaG9va3MgKHByb3RvY29sIGhvb2sgZm9yIGZpbGU6LCBub2RlLmpzIGhvb2spIFxyXG4gKiBpbmRlcGVuZGVudCBvZiBpbml0aWFsaXppbmcgdGhlIGNvbXBpbGVyLiBUaGlzIG1ldGhvZCBpcyB1c3VhbGx5IGNhbGxlZCBieVxyXG4gKiBpbml0IGluc3RlYWQgb2YgZGlyZWN0bHlcclxuICogXHJcbiAqIEBwYXJhbSB7Q29tcGlsZXJIb3N0fSBjb21waWxlckhvc3QgIFRoZSBjb21waWxlciBob3N0IHRvIHVzZS5cclxuICogIFxyXG4gKi8gXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0KSB7XHJcbiAgbGV0IGdsb2JhbFZhciA9IChnbG9iYWwgfHwgd2luZG93KTtcclxuICBnbG9iYWxWYXIuZ2xvYmFsQ29tcGlsZXJIb3N0ID0gY29tcGlsZXJIb3N0O1xyXG5cclxuICByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24oY29tcGlsZXJIb3N0KTtcclxuXHJcbiAgaWYgKCd0eXBlJyBpbiBwcm9jZXNzICYmIHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInKSB7XHJcbiAgICBjb25zdCB7IGFwcCB9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcclxuICAgIFxyXG4gICAgbGV0IHByb3RvaWZ5ID0gZnVuY3Rpb24oKSB7IGluaXRpYWxpemVQcm90b2NvbEhvb2soY29tcGlsZXJIb3N0KTsgfTtcclxuICAgIGlmIChhcHAuaXNSZWFkeSgpKSB7XHJcbiAgICAgIHByb3RvaWZ5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcHAub24oJ3JlYWR5JywgcHJvdG9pZnkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGVsZWN0cm9uLWNvbXBpbGUgYW5kIHNldCBpdCB1cCwgZWl0aGVyIGZvciBkZXZlbG9wbWVudCBvciBcclxuICogcHJvZHVjdGlvbiB1c2UuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyB0aGUgb25seSBtZXRob2QgeW91IG5lZWQgdG8gdXNlIGluIG9yZGVyXHJcbiAqIHRvIHVzZSBlbGVjdHJvbi1jb21waWxlLlxyXG4gKiAgXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbWFpbk1vZHVsZSAgVGhlIG1vZHVsZSB0byByZXF1aXJlIGluLCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGluZyBpbml0LCB0aGF0IHdpbGwgc3RhcnQgeW91ciBhcHAuIFdyaXRlIHRoaXMgXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgaWYgeW91IHdlcmUgd3JpdGluZyBhIHJlcXVpcmUgY2FsbCBmcm9tIGhlcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge2Jvb2x9IHByb2R1Y3Rpb25Nb2RlICAgSWYgZXhwbGljaXRseSBUcnVlL0ZhbHNlLCB3aWxsIHNldCByZWFkLW9ubHlcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIHRvIGJlIGRpc2FibGVkL2VuYWJsZWQuIElmIG5vdCwgd2UnbGxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWVzcyBiYXNlZCBvbiB0aGUgcHJlc2VuY2Ugb2YgYSBwcm9kdWN0aW9uXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuXHJcbiAqLyBcclxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoYXBwUm9vdCwgbWFpbk1vZHVsZSwgcHJvZHVjdGlvbk1vZGUgPSBudWxsKSB7XHJcbiAgbGV0IGNvbXBpbGVySG9zdCA9IG51bGw7XHJcbiAgbGV0IGNhY2hlRGlyID0gcGF0aC5qb2luKGFwcFJvb3QsICcuY2FjaGUnKTtcclxuICBcclxuICBpZiAocHJvZHVjdGlvbk1vZGUgPT09IG51bGwpIHtcclxuICAgIHByb2R1Y3Rpb25Nb2RlID0gISFzdGF0U3luY05vRXhjZXB0aW9uKGNhY2hlRGlyKTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKHByb2R1Y3Rpb25Nb2RlKSB7XHJcbiAgICAvLyBJbiByZWFkLW9ubHkgbW9kZSwgd2UnbGwgYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpcyBpbiBgYXBwUm9vdC8uY2FjaGVgXHJcbiAgICBjb21waWxlckhvc3QgPSBDb21waWxlckhvc3QuY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMoY2FjaGVEaXIsIGFwcFJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb21waWxlckhvc3QgPSBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKGFwcFJvb3QpO1xyXG4gIH1cclxuICBcclxuICBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0KTtcclxuICByZXF1aXJlLm1haW4ucmVxdWlyZShtYWluTW9kdWxlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIENvbXBpbGVySG9zdH0gd2l0aCB0aGUgZ2l2ZW4gaW5mb3JtYXRpb24uIFRoaXMgbWV0aG9kIGlzXHJcbiAqIHVzdWFsbHkgY2FsbGVkIGJ5IHtAbGluayBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3R9LlxyXG4gKiAgXHJcbiAqIEBwcml2YXRlXHJcbiAqLyBcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKGluZm8pIHtcclxuICBsZXQgY29tcGlsZXJzID0gY3JlYXRlQ29tcGlsZXJzKCk7XHJcbiAgbGV0IHJvb3RDYWNoZURpciA9IGluZm8ucm9vdENhY2hlRGlyIHx8IGNhbGN1bGF0ZURlZmF1bHRDb21waWxlQ2FjaGVEaXJlY3RvcnkoKTtcclxuICBcclxuICBkKGBDcmVhdGluZyBDb21waWxlckhvc3Q6ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9LCByb290Q2FjaGVEaXIgPSAke3Jvb3RDYWNoZURpcn1gKTtcclxuICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gbmV3IEZpbGVDaGFuZ2VkQ2FjaGUoaW5mby5hcHBSb290KTtcclxuICBsZXQgcmV0ID0gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCBmYWxzZSwgY29tcGlsZXJzWyd0ZXh0L3BsYWluJ10pO1xyXG4gIFxyXG4gIF8uZWFjaChPYmplY3Qua2V5cyhpbmZvLm9wdGlvbnMgfHwge30pLCAoeCkgPT4ge1xyXG4gICAgbGV0IG9wdHMgPSBpbmZvLm9wdGlvbnNbeF07XHJcbiAgICBpZiAoISh4IGluIGNvbXBpbGVycykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBjb21waWxlciBzZXR0aW5ncyBmb3IgbWlzc2luZyBjb21waWxlcjogJHt4fWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkKGBTZXR0aW5nIG9wdGlvbnMgZm9yICR7eH06ICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9YCk7XHJcbiAgICBjb21waWxlcnNbeF0uY29tcGlsZXJPcHRpb25zID0gb3B0cztcclxuICB9KTtcclxuICBcclxuICAvLyBOQjogSXQncyBzdXBlciBpbXBvcnRhbnQgdGhhdCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgY29uZmlndXJhdGlvbiBpcyBzYXZlZFxyXG4gIC8vIG91dCwgYmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlLXJlYWQgaXQgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3NcclxuICBkKGBDcmVhdGVkIGNvbXBpbGVyIGhvc3Qgd2l0aCBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KGluZm8pfWApO1xyXG4gIHJldC5zYXZlQ29uZmlndXJhdGlvblN5bmMoKTtcclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbXBpbGVyIGhvc3QgZnJvbSBhIC5iYWJlbHJjIGZpbGUuIFRoaXMgbWV0aG9kIGlzIHVzdWFsbHkgY2FsbGVkXHJcbiAqIGZyb20ge0BsaW5rIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdH0gaW5zdGVhZCBvZiB1c2VkIGRpcmVjdGx5LlxyXG4gKiAgXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgVGhlIHBhdGggdG8gYSAuYmFiZWxyYyBmaWxlXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyIChvcHRpb25hbCkgIFRoZSBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcclxuICovIFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMoZmlsZSwgcm9vdENhY2hlRGlyPW51bGwpIHtcclxuICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUsICd1dGY4JykpO1xyXG4gIFxyXG4gIC8vIHBhY2thZ2UuanNvblxyXG4gIGlmICgnYmFiZWwnIGluIGluZm8pIHtcclxuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xyXG4gIH1cclxuICBcclxuICBpZiAoJ2VudicgaW4gaW5mbykge1xyXG4gICAgbGV0IG91ckVudiA9IHByb2Nlc3MuZW52LkJBQkVMX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFyZSB3ZSBzdGlsbCBwYWNrYWdlLmpzb24gKGkuZS4gaXMgdGhlcmUgbm8gYmFiZWwgaW5mbyB3aGF0c29ldmVyPylcclxuICBpZiAoJ25hbWUnIGluIGluZm8gJiYgJ3ZlcnNpb24nIGluIGluZm8pIHtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XHJcbiAgICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSxcclxuICAgICAgcm9vdENhY2hlRGlyXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnOiBpbmZvXHJcbiAgICB9LFxyXG4gICAgcm9vdENhY2hlRGlyXHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbXBpbGVyIGhvc3QgZnJvbSBhIC5jb21waWxlcmMgZmlsZS4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWRcclxuICogZnJvbSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fSBpbnN0ZWFkIG9mIHVzZWQgZGlyZWN0bHkuXHJcbiAqICBcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlICBUaGUgcGF0aCB0byBhIC5jb21waWxlcmMgZmlsZVxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAob3B0aW9uYWwpICBUaGUgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHNldC11cCBjb21waWxlciBob3N0XHJcbiAqLyBcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsKSB7XHJcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlLCAndXRmOCcpKTtcclxuICBcclxuICBpZiAoJ2VudicgaW4gaW5mbykge1xyXG4gICAgbGV0IG91ckVudiA9IHByb2Nlc3MuZW52LkVMRUNUUk9OX0NPTVBJTEVfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XHJcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IGluZm8sXHJcbiAgICByb290Q2FjaGVEaXJcclxuICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY29uZmlndXJlZCB7QGxpbmsgQ29tcGlsZXJIb3N0fSBpbnN0YW5jZSBmcm9tIHRoZSBwcm9qZWN0IHJvb3QgXHJcbiAqIGRpcmVjdG9yeS4gVGhpcyBtZXRob2QgZmlyc3Qgc2VhcmNoZXMgZm9yIGEgLmNvbXBpbGVyYywgdGhlbiBmYWxscyBiYWNrIHRvIHRoZVxyXG4gKiBkZWZhdWx0IGxvY2F0aW9ucyBmb3IgQmFiZWwgY29uZmlndXJhdGlvbiBpbmZvLiBJZiBuZWl0aGVyIGFyZSBmb3VuZCwgZGVmYXVsdHNcclxuICogdG8gc3RhbmRhcmQgc2V0dGluZ3NcclxuICogIFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXIgIFRoZSByb290IGFwcGxpY2F0aW9uIGRpcmVjdG9yeSAoaS5lLiB0aGUgZGlyZWN0b3J5XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBoYXMgdGhlIGFwcCdzIHBhY2thZ2UuanNvbilcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cclxuICpcclxuICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSBzZXQtdXAgY29tcGlsZXIgaG9zdFxyXG4gKi8gXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3Qocm9vdERpciwgcm9vdENhY2hlRGlyPW51bGwpIHtcclxuICBsZXQgY29tcGlsZXJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuY29tcGlsZXJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xyXG4gICAgZChgRm91bmQgYSAuY29tcGlsZXJjIGF0ICR7Y29tcGlsZXJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBhd2FpdCBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZShjb21waWxlcmMsIHJvb3RDYWNoZURpcik7XHJcbiAgfVxyXG4gIFxyXG4gIGxldCBiYWJlbHJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuYmFiZWxyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGJhYmVscmMpKSB7XHJcbiAgICBkKGBGb3VuZCBhIC5iYWJlbHJjIGF0ICR7YmFiZWxyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMoYmFiZWxyYywgcm9vdENhY2hlRGlyKTtcclxuICB9XHJcbiAgICBcclxuICBkKGBVc2luZyBwYWNrYWdlLmpzb24gb3IgZGVmYXVsdCBwYXJhbWV0ZXJzIGF0ICR7cm9vdERpcn1gKTtcclxuICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSwgcm9vdENhY2hlRGlyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjU3luYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XHJcbiAgXHJcbiAgLy8gcGFja2FnZS5qc29uXHJcbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xyXG4gICAgaW5mbyA9IGluZm8uYmFiZWw7XHJcbiAgfVxyXG4gIFxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuQkFCRUxfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XHJcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcclxuICB9XHJcbiAgXHJcbiAgLy8gQXJlIHdlIHN0aWxsIHBhY2thZ2UuanNvbiAoaS5lLiBpcyB0aGVyZSBubyBiYWJlbCBpbmZvIHdoYXRzb2V2ZXI/KVxyXG4gIGlmICgnbmFtZScgaW4gaW5mbyAmJiAndmVyc2lvbicgaW4gaW5mbykge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgICBvcHRpb25zOiBnZXREZWZhdWx0Q29uZmlndXJhdGlvbigpLFxyXG4gICAgICByb290Q2FjaGVEaXJcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cclxuICAgIH0sXHJcbiAgICByb290Q2FjaGVEaXJcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlU3luYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XHJcbiAgXHJcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcclxuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5FTEVDVFJPTl9DT01QSUxFX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XHJcbiAgICBhcHBSb290OiBwYXRoLmRpcm5hbWUoZmlsZSksXHJcbiAgICBvcHRpb25zOiBpbmZvLFxyXG4gICAgcm9vdENhY2hlRGlyXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKHJvb3REaXIsIHJvb3RDYWNoZURpcj1udWxsKSB7XHJcbiAgbGV0IGNvbXBpbGVyYyA9IHBhdGguam9pbihyb290RGlyLCAnLmNvbXBpbGVyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGNvbXBpbGVyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGVTeW5jKGNvbXBpbGVyYywgcm9vdENhY2hlRGlyKTtcclxuICB9XHJcbiAgXHJcbiAgbGV0IGJhYmVscmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5iYWJlbHJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oYmFiZWxyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmJhYmVscmMgYXQgJHtiYWJlbHJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMoYmFiZWxyYywgcm9vdENhY2hlRGlyKTtcclxuICB9XHJcbiAgICBcclxuICBkKGBVc2luZyBwYWNrYWdlLmpzb24gb3IgZGVmYXVsdCBwYXJhbWV0ZXJzIGF0ICR7cm9vdERpcn1gKTtcclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKHBhdGguam9pbihyb290RGlyLCAncGFja2FnZS5qc29uJyksIHJvb3RDYWNoZURpcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoYXQgZWxlY3Ryb24tY29tcGlsZSB3b3VsZCB1c2UgYXMgYSBkZWZhdWx0IHJvb3RDYWNoZURpci4gVXN1YWxseSBvbmx5XHJcbiAqIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xyXG4gKiAgXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gIEEgcGF0aCB0aGF0IG1heSBvciBtYXkgbm90IGV4aXN0IHdoZXJlIGVsZWN0cm9uLWNvbXBpbGUgd291bGRcclxuICogICAgICAgICAgICAgICAgICAgc2V0IHVwIGEgZGV2ZWxvcG1lbnQgbW9kZSBjYWNoZS5cclxuICovIFxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVmYXVsdENvbXBpbGVDYWNoZURpcmVjdG9yeSgpIHtcclxuICBsZXQgdG1wRGlyID0gcHJvY2Vzcy5lbnYuVEVNUCB8fCBwcm9jZXNzLmVudi5UTVBESVIgfHwgJy90bXAnO1xyXG4gIGxldCBoYXNoID0gcmVxdWlyZSgnY3J5cHRvJykuY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHByb2Nlc3MuZXhlY1BhdGgpLmRpZ2VzdCgnaGV4Jyk7XHJcblxyXG4gIGxldCBjYWNoZURpciA9IHBhdGguam9pbih0bXBEaXIsIGBjb21waWxlQ2FjaGVfJHtoYXNofWApO1xyXG4gIG1rZGlycC5zeW5jKGNhY2hlRGlyKTtcclxuICBcclxuICBkKGBVc2luZyBkZWZhdWx0IGNhY2hlIGRpcmVjdG9yeTogJHtjYWNoZURpcn1gKTtcclxuICByZXR1cm4gY2FjaGVEaXI7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGVmYXVsdCAuY29uZmlncmMgaWYgbm8gY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQuXHJcbiAqICBcclxuICogQHJldHVybiB7T2JqZWN0fSAgQSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIHNldHRpbmdzIGZvciBlbGVjdHJvbi1jb21waWxlci5cclxuICovIFxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jzoge1xyXG4gICAgICBcInByZXNldHNcIjogW1wic3RhZ2UtMFwiLCBcImVzMjAxNVwiLCBcInJlYWN0XCJdLFxyXG4gICAgICBcInNvdXJjZU1hcHNcIjogXCJpbmxpbmVcIlxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIGFsbCBjb21waWxlcnMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IFxyXG4gKiBlbGVjdHJvbi1jb21waWxlIGFuZCB1c2UgdGhlbSBkaXJlY3RseS4gQ3VycmVudGx5IHN1cHBvcnRzIEJhYmVsLCBDb2ZmZWVTY3JpcHQsIFxyXG4gKiBUeXBlU2NyaXB0LCBMRVNTLCBhbmQgSmFkZS5cclxuICogIFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICBBbiBPYmplY3Qgd2hvc2UgS2V5cyBhcmUgTUlNRSB0eXBlcywgYW5kIHdob3NlIHZhbHVlcyBcclxuICogYXJlIGluc3RhbmNlcyBvZiBAe2xpbmsgQ29tcGlsZXJCYXNlfS5cclxuICovIFxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJzKCkge1xyXG4gIGlmICghYWxsQ29tcGlsZXJDbGFzc2VzKSB7XHJcbiAgICAvLyBGaXJzdCB3ZSB3YW50IHRvIHNlZSBpZiBlbGVjdHJvbi1jb21waWxlcnMgaXRzZWxmIGhhcyBiZWVuIGluc3RhbGxlZCB3aXRoXHJcbiAgICAvLyBkZXZEZXBlbmRlbmNpZXMuIElmIHRoYXQncyBub3QgdGhlIGNhc2UsIGNoZWNrIHRvIHNlZSBpZlxyXG4gICAgLy8gZWxlY3Ryb24tY29tcGlsZXJzIGlzIGluc3RhbGxlZCBhcyBhIHBlZXIgZGVwZW5kZW5jeSAocHJvYmFibHkgYXMgYVxyXG4gICAgLy8gZGV2RGVwZW5kZW5jeSBvZiB0aGUgcm9vdCBwcm9qZWN0KS5cclxuICAgIGNvbnN0IGxvY2F0aW9ucyA9IFsnZWxlY3Ryb24tY29tcGlsZXJzJywgJy4uLy4uL2VsZWN0cm9uLWNvbXBpbGVycyddO1xyXG5cclxuICAgIGZvciAobGV0IGxvY2F0aW9uIG9mIGxvY2F0aW9ucykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGFsbENvbXBpbGVyQ2xhc3NlcyA9IHJlcXVpcmUobG9jYXRpb24pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gWW9sb1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhbGxDb21waWxlckNsYXNzZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlY3Ryb24gY29tcGlsZXJzIG5vdCBmb3VuZCBidXQgd2VyZSByZXF1ZXN0ZWQgdG8gYmUgbG9hZGVkXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTkI6IE5vdGUgdGhhdCB0aGlzIGNvZGUgaXMgY2FyZWZ1bGx5IHNldCB1cCBzbyB0aGF0IElubGluZUh0bWxDb21waWxlciBcclxuICAvLyAoaS5lLiBjbGFzc2VzIHdpdGggYGNyZWF0ZUZyb21Db21waWxlcnNgKSBpbml0aWFsbHkgZ2V0IGFuIGVtcHR5IG9iamVjdCxcclxuICAvLyBidXQgd2lsbCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2Ygd2hhdCB3ZSByZXR1cm4sIHdoaWNoXHJcbiAgLy8gcmVzb2x2ZXMgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2UnZCBvdGhlcndpc2UgaGF2ZSBoZXJlLlxyXG4gIGxldCByZXQgPSB7fTtcclxuICBsZXQgaW5zdGFudGlhdGVkQ2xhc3NlcyA9IF8ubWFwKGFsbENvbXBpbGVyQ2xhc3NlcywgKEtsYXNzKSA9PiB7XHJcbiAgICBpZiAoJ2NyZWF0ZUZyb21Db21waWxlcnMnIGluIEtsYXNzKSB7XHJcbiAgICAgIHJldHVybiBLbGFzcy5jcmVhdGVGcm9tQ29tcGlsZXJzKHJldCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmV3IEtsYXNzKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIF8ucmVkdWNlKGluc3RhbnRpYXRlZENsYXNzZXMsIChhY2MseCkgPT4ge1xyXG4gICAgbGV0IEtsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGZvciAobGV0IHR5cGUgb2YgS2xhc3MuZ2V0SW5wdXRNaW1lVHlwZXMoKSkgeyBhY2NbdHlwZV0gPSB4OyB9XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIHJldCk7XHJcbiAgXHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG4iXX0=