'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('./promise');

var _forAllFiles = require('./for-all-files');

var _compileCache = require('./compile-cache');

var _compileCache2 = _interopRequireDefault(_compileCache);

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var d = require('debug')('electron-compile:compiler-host');

// This isn't even my
var finalForms = {
  'text/javascript': true,
  'application/javascript': true,
  'text/html': true,
  'text/css': true,
  'image/svg+xml': true
};

/**
 * This class is the top-level class that encapsulates all of the logic of 
 * compiling and caching application code. If you're looking for a "Main class",
 * this is it.
 * 
 * This class can be created directly but it is usually created via the methods
 * in config-parser, which will among other things, set up the compiler options
 * given a project root.
 * 
 * CompilerHost is also the top-level class that knows how to serialize all of the
 * information necessary to recreate itself, either as a development host (i.e.
 * will allow cache misses and actual compilation), or as a read-only version of
 * itself for production.
 */

var CompilerHost = (function () {
  /**  
   * Creates an instance of CompilerHost. You probably want to use the methods
   * in config-parser for development, or {@link createReadonlyFromConfiguration}
   * for production instead.
   *    
   * @param  {string} rootCacheDir  The root directory to use for the cache
   * 
   * @param  {Object} compilers  an Object whose keys are input MIME types and
   *                             whose values are instances of CompilerBase. Create
   *                             this via the {@link createCompilers} method in
   *                             config-parser.
   * 
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is 
   *                                             optionally pre-loaded.
   * 
   * @param  {boolean} readOnlyMode  If True, cache misses will fail and 
   *                                 compilation will not be attempted.
   * 
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   */

  function CompilerHost(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {
    var fallbackCompiler = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

    _classCallCheck(this, CompilerHost);

    var compilersByMimeType = _lodash2.default.assign({}, compilers);
    _lodash2.default.assign(this, { rootCacheDir: rootCacheDir, compilersByMimeType: compilersByMimeType, fileChangeCache: fileChangeCache, readOnlyMode: readOnlyMode, fallbackCompiler: fallbackCompiler });
    this.appRoot = this.fileChangeCache.appRoot;

    this.cachesForCompilers = _lodash2.default.reduce(Object.keys(compilersByMimeType), function (acc, x) {
      var compiler = compilersByMimeType[x];
      if (acc.has(compiler)) return acc;

      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode));
      return acc;
    }, new Map());
  }

  /**    
   * Creates a production-mode CompilerHost from the previously saved 
   * configuration
   *    
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present. 
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */

  _createClass(CompilerHost, [{
    key: 'saveConfiguration',

    /**  
     * Saves the current compiler configuration to a file that 
     * {@link createReadonlyFromConfiguration} can use to recreate the current 
     * compiler environment
     *    
     * @return {Promise}  Completion
     */
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var serializedCompilerOpts, info, target, buf;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                serializedCompilerOpts = _lodash2.default.reduce(Object.keys(this.compilersByMimeType), function (acc, x) {
                  var compiler = _this.compilersByMimeType[x];
                  var Klass = Object.getPrototypeOf(compiler).constructor;

                  var val = {
                    name: Klass.name,
                    inputMimeTypes: Klass.getInputMimeTypes(),
                    compilerOptions: compiler.compilerOptions,
                    compilerVersion: compiler.getCompilerVersion()
                  };

                  acc[x] = val;
                  return acc;
                }, {});
                info = {
                  fileChangeCache: this.fileChangeCache.getSavedData(),
                  compilers: serializedCompilerOpts
                };
                target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
                _context.next = 5;
                return _promise.pzlib.gzip(new Buffer(JSON.stringify(info)));

              case 5:
                buf = _context.sent;
                _context.next = 8;
                return _promise.pfs.writeFile(target, buf);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function saveConfiguration() {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Compiles a file and returns the compiled result.
     *    
     * @param  {string} filePath  The path to the file to compile
     *
     * @return {Promise<object>}  An Object with the compiled result
     *
     * @property {Object} hashInfo  The hash information returned from getHashForPath
     * @property {string} code  The source code if the file was a text file
     * @property {Buffer} binaryData  The file if it was a binary file
     * @property {string} mimeType  The MIME type saved in the cache.
     * @property {string[]} dependentFiles  The dependent files returned from 
     *                                      compiling the file, if any.
     */

  }, {
    key: 'compile',
    value: function compile(filePath) {
      return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);
    }

    /**  
     * Handles compilation in read-only mode
     *
     * @private
     */

  }, {
    key: 'compileReadOnly',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(filePath) {
        var type, hashInfo, compiler, _ref, _code, _binaryData, _mimeType, cache, _ref2, code, binaryData, mimeType;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // We guarantee that node_modules are always shipped directly
                type = _mimeTypes2.default.lookup(filePath);

                if (!_fileChangeCache2.default.isInNodeModules(filePath)) {
                  _context2.next = 7;
                  break;
                }

                _context2.t0 = type || 'application/javascript';
                _context2.next = 5;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 5:
                _context2.t1 = _context2.sent;
                return _context2.abrupt('return', {
                  mimeType: _context2.t0,
                  code: _context2.t1
                });

              case 7:
                _context2.next = 9;
                return this.fileChangeCache.getHashForPath(filePath);

              case 9:
                hashInfo = _context2.sent;

                // NB: Here, we're basically only using the compiler here to find
                // the appropriate CompileCache
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

                if (compiler) {
                  _context2.next = 20;
                  break;
                }

                compiler = this.fallbackCompiler;

                _context2.next = 15;
                return compiler.get(filePath);

              case 15:
                _ref = _context2.sent;
                _code = _ref.code;
                _binaryData = _ref.binaryData;
                _mimeType = _ref.mimeType;
                return _context2.abrupt('return', { code: _code || _binaryData, mimeType: _mimeType });

              case 20:
                cache = this.cachesForCompilers.get(compiler);
                _context2.next = 23;
                return cache.get(filePath);

              case 23:
                _ref2 = _context2.sent;
                code = _ref2.code;
                binaryData = _ref2.binaryData;
                mimeType = _ref2.mimeType;

                code = code || binaryData;

                if (!(!code || !mimeType)) {
                  _context2.next = 30;
                  break;
                }

                throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');

              case 30:
                return _context2.abrupt('return', { code: code, mimeType: mimeType });

              case 31:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function compileReadOnly(_x2) {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Handles compilation in read-write mode
     *
     * @private
     */

  }, {
    key: 'fullCompile',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(filePath) {
        var _this2 = this;

        var hashInfo, type, code, compiler, cache;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                d('Compiling ' + filePath);

                _context3.next = 3;
                return this.fileChangeCache.getHashForPath(filePath);

              case 3:
                hashInfo = _context3.sent;
                type = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isInNodeModules) {
                  _context3.next = 13;
                  break;
                }

                _context3.t0 = hashInfo.sourceCode;

                if (_context3.t0) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 10;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 10:
                _context3.t0 = _context3.sent;

              case 11:
                code = _context3.t0;
                return _context3.abrupt('return', { code: code, mimeType: type });

              case 13:
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

                if (!compiler) {
                  d('Falling back to passthrough compiler for ' + filePath);
                  compiler = this.fallbackCompiler;
                }

                if (compiler) {
                  _context3.next = 17;
                  break;
                }

                throw new Error('Couldn\'t find a compiler for ' + filePath);

              case 17:
                cache = this.cachesForCompilers.get(compiler);
                _context3.next = 20;
                return cache.getOrFetch(filePath, function (filePath, hashInfo) {
                  return _this2.compileUncached(filePath, hashInfo, compiler);
                });

              case 20:
                return _context3.abrupt('return', _context3.sent);

              case 21:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function fullCompile(_x3) {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Handles invoking compilers independent of caching
     *
     * @private
     */

  }, {
    key: 'compileUncached',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(filePath, hashInfo, compiler) {
        var inputMimeType, ctx, code, dependentFiles, result, shouldInlineHtmlify, isPassthrough;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                inputMimeType = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isFileBinary) {
                  _context4.next = 11;
                  break;
                }

                _context4.t0 = hashInfo.binaryData;

                if (_context4.t0) {
                  _context4.next = 7;
                  break;
                }

                _context4.next = 6;
                return _promise.pfs.readFile(filePath);

              case 6:
                _context4.t0 = _context4.sent;

              case 7:
                _context4.t1 = _context4.t0;
                _context4.t2 = inputMimeType;
                _context4.t3 = [];
                return _context4.abrupt('return', {
                  binaryData: _context4.t1,
                  mimeType: _context4.t2,
                  dependentFiles: _context4.t3
                });

              case 11:
                ctx = {};
                _context4.t4 = hashInfo.sourceCode;

                if (_context4.t4) {
                  _context4.next = 17;
                  break;
                }

                _context4.next = 16;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 16:
                _context4.t4 = _context4.sent;

              case 17:
                code = _context4.t4;
                _context4.next = 20;
                return compiler.shouldCompileFile(code, ctx);

              case 20:
                if (_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                d('Compiler returned false for shouldCompileFile: ' + filePath);
                return _context4.abrupt('return', { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] });

              case 23:
                _context4.next = 25;
                return compiler.determineDependentFiles(code, filePath, ctx);

              case 25:
                dependentFiles = _context4.sent;

                d('Using compiler options: ' + JSON.stringify(compiler.compilerOptions));
                _context4.next = 29;
                return compiler.compile(code, filePath, ctx);

              case 29:
                result = _context4.sent;
                shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';
                isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

                if (!(finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough)) {
                  _context4.next = 36;
                  break;
                }

                return _context4.abrupt('return', _lodash2.default.assign(result, { dependentFiles: dependentFiles }));

              case 36:
                d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

                hashInfo = _lodash2.default.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
                compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

                if (compiler) {
                  _context4.next = 42;
                  break;
                }

                d('Recursive compile failed - intermediate result: ' + JSON.stringify(result));

                throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');

              case 42:
                _context4.next = 44;
                return this.compileUncached(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);

              case 44:
                return _context4.abrupt('return', _context4.sent);

              case 45:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function compileUncached(_x4, _x5, _x6) {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Pre-caches an entire directory of files recursively. Usually used for 
     * building custom compiler tooling.
     *    
     * @param  {string} rootDirectory  The top-level directory to compile
     *
     * @param  {Function} shouldCompile (optional)  A Function which allows the 
     *                                  caller to disable compiling certain files.
     *                                  It takes a fully-qualified path to a file,
     *                                  and should return a Boolean.
     *
     * @return {Promise}  Completion.
     */

  }, {
    key: 'compileAll',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(rootDirectory) {
        var _this3 = this;

        var shouldCompile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
        var should;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                should = shouldCompile || function () {
                  return true;
                };

                _context5.next = 3;
                return (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {
                  if (!should(f)) return;

                  d('Compiling ' + f);
                  return _this3.compile(f, _this3.compilersByMimeType);
                });

              case 3:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function compileAll(_x8) {
        return ref.apply(this, arguments);
      };
    })()

    /*
     * Sync Methods
     */

  }, {
    key: 'compileSync',
    value: function compileSync(filePath) {
      return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);
    }
  }, {
    key: 'saveConfigurationSync',
    value: function saveConfigurationSync() {
      var _this4 = this;

      var serializedCompilerOpts = _lodash2.default.reduce(Object.keys(this.compilersByMimeType), function (acc, x) {
        var compiler = _this4.compilersByMimeType[x];
        var Klass = Object.getPrototypeOf(compiler).constructor;

        var val = {
          name: Klass.name,
          inputMimeTypes: Klass.getInputMimeTypes(),
          compilerOptions: compiler.compilerOptions,
          compilerVersion: compiler.getCompilerVersion()
        };

        acc[x] = val;
        return acc;
      }, {});

      var info = {
        fileChangeCache: this.fileChangeCache.getSavedData(),
        compilers: serializedCompilerOpts
      };

      var target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
      var buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(info)));
      _fs2.default.writeFileSync(target, buf);
    }
  }, {
    key: 'compileReadOnlySync',
    value: function compileReadOnlySync(filePath) {
      // We guarantee that node_modules are always shipped directly
      var type = _mimeTypes2.default.lookup(filePath);
      if (_fileChangeCache2.default.isInNodeModules(filePath)) {
        return {
          mimeType: type || 'application/javascript',
          code: _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);

      // We guarantee that node_modules are always shipped directly
      if (hashInfo.isInNodeModules) {
        return {
          mimeType: type,
          code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      // NB: Here, we're basically only using the compiler here to find
      // the appropriate CompileCache
      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        compiler = this.fallbackCompiler;

        var _compiler$getSync = compiler.getSync(filePath);

        var _code2 = _compiler$getSync.code;
        var _binaryData2 = _compiler$getSync.binaryData;
        var _mimeType2 = _compiler$getSync.mimeType;

        return { code: _code2 || _binaryData2, mimeType: _mimeType2 };
      }

      var cache = this.cachesForCompilers.get(compiler);

      var _cache$getSync = cache.getSync(filePath);

      var code = _cache$getSync.code;
      var binaryData = _cache$getSync.binaryData;
      var mimeType = _cache$getSync.mimeType;

      code = code || binaryData;
      if (!code || !mimeType) {
        throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');
      }

      return { code: code, mimeType: mimeType };
    }
  }, {
    key: 'fullCompileSync',
    value: function fullCompileSync(filePath) {
      var _this5 = this;

      d('Compiling ' + filePath);

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);
      var type = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isInNodeModules) {
        var _code3 = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');
        return { code: _code3, mimeType: type };
      }

      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        d('Falling back to passthrough compiler for ' + filePath);
        compiler = this.fallbackCompiler;
      }

      if (!compiler) {
        throw new Error('Couldn\'t find a compiler for ' + filePath);
      }

      var cache = this.cachesForCompilers.get(compiler);
      return cache.getOrFetchSync(filePath, function (filePath, hashInfo) {
        return _this5.compileUncachedSync(filePath, hashInfo, compiler);
      });
    }
  }, {
    key: 'compileUncachedSync',
    value: function compileUncachedSync(filePath, hashInfo, compiler) {
      var inputMimeType = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isFileBinary) {
        return {
          binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),
          mimeType: inputMimeType,
          dependentFiles: []
        };
      }

      var ctx = {};
      var code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');

      if (!compiler.shouldCompileFileSync(code, ctx)) {
        d('Compiler returned false for shouldCompileFile: ' + filePath);
        return { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
      }

      var dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);

      var result = compiler.compileSync(code, filePath, ctx);

      var shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

      var isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
        // Got something we can use in-browser, let's return it
        return _lodash2.default.assign(result, { dependentFiles: dependentFiles });
      } else {
        d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

        hashInfo = _lodash2.default.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
        compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

        if (!compiler) {
          d('Recursive compile failed - intermediate result: ' + JSON.stringify(result));

          throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');
        }

        return this.compileUncachedSync(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);
      }
    }
  }, {
    key: 'compileAllSync',
    value: function compileAllSync(rootDirectory) {
      var _this6 = this;

      var shouldCompile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      var should = shouldCompile || function () {
        return true;
      };

      (0, _forAllFiles.forAllFilesSync)(rootDirectory, function (f) {
        if (!should(f)) return;
        return _this6.compileSync(f, _this6.compilersByMimeType);
      });
    }

    /*
     * Other stuff
     */

    /**
     * Returns the passthrough compiler 
     *
     * @private
     */

  }, {
    key: 'getPassthroughCompiler',
    value: function getPassthroughCompiler() {
      return this.compilersByMimeType['text/plain'];
    }

    /**
     * Determines whether we should even try to compile the content. Note that in
     * some cases, content will still be in cache even if this returns true, and
     * in other cases (isInNodeModules), we'll know explicitly to not even bother
     * looking in the cache.
     *    
     * @private
     */

  }], [{
    key: 'createReadonlyFromConfiguration',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(rootCacheDir, appRoot) {
        var fallbackCompiler = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
        var target, buf, info, fileChangeCache, compilers;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context6.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context6.sent;
                _context6.t0 = JSON;
                _context6.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context6.t1 = _context6.sent;
                info = _context6.t0.parse.call(_context6.t0, _context6.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);
                compilers = _lodash2.default.reduce(Object.keys(info.compilers), function (acc, x) {
                  var cur = info.compilers[x];
                  acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

                  return acc;
                }, {});
                return _context6.abrupt('return', new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler));

              case 12:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function createReadonlyFromConfiguration(_x11, _x12) {
        return ref.apply(this, arguments);
      };
    })()

    /**    
     * Creates a development-mode CompilerHost from the previously saved 
     * configuration.
     *    
     * @param  {string} rootCacheDir  The root directory to use for the cache. This
     *                                cache must have cache information saved via
     *                                {@link saveConfiguration}
     *
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     *
     * @param  {Object} compilersByMimeType  an Object whose keys are input MIME 
     *                                       types and whose values are instances 
     *                                       of CompilerBase. Create this via the 
     *                                       {@link createCompilers} method in 
     *                                       config-parser.
     * 
     * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
     *                                         which doesn't have a matching compiler,
     *                                         this compiler will be used instead. If
     *                                         null, will fail compilation. A good
     *                                         alternate fallback is the compiler for
     *                                         'text/plain', which is guaranteed to be
     *                                         present. 
     *
     * @return {Promise<CompilerHost>}  A read-only CompilerHost
     */

  }, {
    key: 'createFromConfiguration',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(rootCacheDir, appRoot, compilersByMimeType) {
        var fallbackCompiler = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
        var target, buf, info, fileChangeCache;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context7.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context7.sent;
                _context7.t0 = JSON;
                _context7.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context7.t1 = _context7.sent;
                info = _context7.t0.parse.call(_context7.t0, _context7.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

                _lodash2.default.each(Object.keys(info.compilers), function (x) {
                  var cur = info.compilers[x];
                  compilersByMimeType[x].compilerOptions = cur.compilerOptions;
                });

                return _context7.abrupt('return', new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler));

              case 12:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function createFromConfiguration(_x14, _x15, _x16) {
        return ref.apply(this, arguments);
      };
    })()
  }, {
    key: 'createReadonlyFromConfigurationSync',
    value: function createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {
      var fallbackCompiler = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

      var compilers = _lodash2.default.reduce(Object.keys(info.compilers), function (acc, x) {
        var cur = info.compilers[x];
        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

        return acc;
      }, {});

      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
    }
  }, {
    key: 'createFromConfigurationSync',
    value: function createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {
      var fallbackCompiler = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

      _lodash2.default.each(Object.keys(info.compilers), function (x) {
        var cur = info.compilers[x];
        compilersByMimeType[x].compilerOptions = cur.compilerOptions;
      });

      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
    }
  }, {
    key: 'shouldPassthrough',
    value: function shouldPassthrough(hashInfo) {
      return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
    }
  }]);

  return CompilerHost;
})();

exports.default = CompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUEsSUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGdDQUFnQyxDQUFDOzs7QUFBQyxBQUc3RCxJQUFNLFVBQVUsR0FBRztBQUNqQixtQkFBaUIsRUFBRSxJQUFJO0FBQ3ZCLDBCQUF3QixFQUFFLElBQUk7QUFDOUIsYUFBVyxFQUFFLElBQUk7QUFDakIsWUFBVSxFQUFFLElBQUk7QUFDaEIsaUJBQWUsRUFBRSxJQUFJO0NBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUM7SUFnQm1CLFlBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQi9CLFdBM0JtQixZQUFZLENBMkJuQixZQUFZLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQTJCO1FBQXpCLGdCQUFnQix5REFBRyxJQUFJOzswQkEzQnhFLFlBQVk7O0FBNEI3QixRQUFJLG1CQUFtQixHQUFHLGlCQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbEQscUJBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFDLFlBQVksRUFBWixZQUFZLEVBQUUsbUJBQW1CLEVBQW5CLG1CQUFtQixFQUFFLGVBQWUsRUFBZixlQUFlLEVBQUUsWUFBWSxFQUFaLFlBQVksRUFBRSxnQkFBZ0IsRUFBaEIsZ0JBQWdCLEVBQUMsQ0FBQyxDQUFDO0FBQ3JHLFFBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUM7O0FBRTVDLFFBQUksQ0FBQyxrQkFBa0IsR0FBRyxpQkFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLFVBQUMsR0FBRyxFQUFFLENBQUMsRUFBSztBQUMvRSxVQUFJLFFBQVEsR0FBRyxtQkFB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QUUsbUJBQW1CLEVBQXlCO1VBQXZCLGdCQUFnQix5REFBQyxJQUFJOztBQUNsRyxVQUFJLE1BQU0sR0FBRyxlQUFLLElBQUksQ0FBQyxZQUFZLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztBQUM5RCxVQUFJLEdBQUcsR0FBRyxhQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsQyxVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQUssVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRTVDLFVBQUksZUFBZSxHQUFHLDBCQUFpQixZQUFZLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRTFGLHVCQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxVQUFDLENBQUMsRUFBSztBQUN6QyxZQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVCLDJCQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUMsZUFBZSxDQUFDO09BQzlELENBQUMsQ0FBQzs7QUFFSCxhQUFPLElBQUksWUFBWSxDQUFDLFlBQVksRUFBRSxtQkFBbUIsRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixDQUFDLENBQUM7S0FDdEc7OztzQ0EyTHdCLFFBQVEsRUFBRTtBQUNqQyxhQUFPLFFBQVEsQ0FBQyxVQUFVLElBQUksUUFBUSxDQUFDLGVBQWUsSUFBSSxRQUFRLENBQUMsWUFBWSxJQUFJLFFBQVEsQ0FBQyxZQUFZLENBQUM7S0FDMUc7OztTQWxqQmtCLFlBQVk7OztrQkFBWixZQUFZIiwiZmlsZSI6ImNvbXBpbGVyLWhvc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgbWltZVR5cGVzIGZyb20gJ21pbWUtdHlwZXMnO1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcclxuXHJcbmltcG9ydCB7Zm9yQWxsRmlsZXMsIGZvckFsbEZpbGVzU3luY30gZnJvbSAnLi9mb3ItYWxsLWZpbGVzJztcclxuaW1wb3J0IENvbXBpbGVDYWNoZSBmcm9tICcuL2NvbXBpbGUtY2FjaGUnO1xyXG5pbXBvcnQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICcuL2ZpbGUtY2hhbmdlLWNhY2hlJztcclxuaW1wb3J0IFJlYWRPbmx5Q29tcGlsZXIgZnJvbSAnLi9yZWFkLW9ubHktY29tcGlsZXInO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29tcGlsZXItaG9zdCcpO1xyXG5cclxuLy8gVGhpcyBpc24ndCBldmVuIG15XHJcbmNvbnN0IGZpbmFsRm9ybXMgPSB7XHJcbiAgJ3RleHQvamF2YXNjcmlwdCc6IHRydWUsXHJcbiAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICd0ZXh0L2h0bWwnOiB0cnVlLFxyXG4gICd0ZXh0L2Nzcyc6IHRydWUsXHJcbiAgJ2ltYWdlL3N2Zyt4bWwnOiB0cnVlXHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyB0aGUgdG9wLWxldmVsIGNsYXNzIHRoYXQgZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgbG9naWMgb2YgXHJcbiAqIGNvbXBpbGluZyBhbmQgY2FjaGluZyBhcHBsaWNhdGlvbiBjb2RlLiBJZiB5b3UncmUgbG9va2luZyBmb3IgYSBcIk1haW4gY2xhc3NcIixcclxuICogdGhpcyBpcyBpdC5cclxuICogXHJcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgYnV0IGl0IGlzIHVzdWFsbHkgY3JlYXRlZCB2aWEgdGhlIG1ldGhvZHNcclxuICogaW4gY29uZmlnLXBhcnNlciwgd2hpY2ggd2lsbCBhbW9uZyBvdGhlciB0aGluZ3MsIHNldCB1cCB0aGUgY29tcGlsZXIgb3B0aW9uc1xyXG4gKiBnaXZlbiBhIHByb2plY3Qgcm9vdC5cclxuICogXHJcbiAqIENvbXBpbGVySG9zdCBpcyBhbHNvIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gc2VyaWFsaXplIGFsbCBvZiB0aGVcclxuICogaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIHJlY3JlYXRlIGl0c2VsZiwgZWl0aGVyIGFzIGEgZGV2ZWxvcG1lbnQgaG9zdCAoaS5lLlxyXG4gKiB3aWxsIGFsbG93IGNhY2hlIG1pc3NlcyBhbmQgYWN0dWFsIGNvbXBpbGF0aW9uKSwgb3IgYXMgYSByZWFkLW9ubHkgdmVyc2lvbiBvZlxyXG4gKiBpdHNlbGYgZm9yIHByb2R1Y3Rpb24uXHJcbiAqLyBcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGlsZXJIb3N0IHtcclxuICAvKiogIFxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29tcGlsZXJIb3N0LiBZb3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhlIG1ldGhvZHNcclxuICAgKiBpbiBjb25maWctcGFyc2VyIGZvciBkZXZlbG9wbWVudCwgb3Ige0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259XHJcbiAgICogZm9yIHByb2R1Y3Rpb24gaW5zdGVhZC5cclxuICAgKiAgICBcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnMgIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBpbnB1dCBNSU1FIHR5cGVzIGFuZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9zZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiBDb21waWxlckJhc2UuIENyZWF0ZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHZpYSB0aGUge0BsaW5rIGNyZWF0ZUNvbXBpbGVyc30gbWV0aG9kIGluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy1wYXJzZXIuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXMgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGx5IHByZS1sb2FkZWQuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmVhZE9ubHlNb2RlICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCBmYWlsIGFuZCBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uIHdpbGwgbm90IGJlIGF0dGVtcHRlZC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGZhbGxiYWNrQ29tcGlsZXIgKG9wdGlvbmFsKSAgV2hlbiBhIGZpbGUgaXMgY29tcGlsZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggZG9lc24ndCBoYXZlIGEgbWF0Y2hpbmcgY29tcGlsZXIsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgY29tcGlsZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuIElmXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHdpbGwgZmFpbCBjb21waWxhdGlvbi4gQSBnb29kXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZSBmYWxsYmFjayBpcyB0aGUgY29tcGlsZXIgZm9yXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0L3BsYWluJywgd2hpY2ggaXMgZ3VhcmFudGVlZCB0byBiZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50LlxyXG4gICAqLyAgIFxyXG4gIGNvbnN0cnVjdG9yKHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgZmFsbGJhY2tDb21waWxlciA9IG51bGwpIHtcclxuICAgIGxldCBjb21waWxlcnNCeU1pbWVUeXBlID0gXy5hc3NpZ24oe30sIGNvbXBpbGVycyk7XHJcbiAgICBfLmFzc2lnbih0aGlzLCB7cm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgZmFsbGJhY2tDb21waWxlcn0pO1xyXG4gICAgdGhpcy5hcHBSb290ID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdDtcclxuICAgIFxyXG4gICAgdGhpcy5jYWNoZXNGb3JDb21waWxlcnMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyhjb21waWxlcnNCeU1pbWVUeXBlKSwgKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSBjb21waWxlcnNCeU1pbWVUeXBlW3hdO1xyXG4gICAgICBpZiAoYWNjLmhhcyhjb21waWxlcikpIHJldHVybiBhY2M7XHJcblxyXG4gICAgICBhY2Muc2V0KFxyXG4gICAgICAgIGNvbXBpbGVyLCBcclxuICAgICAgICBDb21waWxlQ2FjaGUuY3JlYXRlRnJvbUNvbXBpbGVyKHJvb3RDYWNoZURpciwgY29tcGlsZXIsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlKSk7XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCBuZXcgTWFwKCkpO1xyXG4gIH1cclxuICAgIFxyXG4gIC8qKiAgICBcclxuICAgKiBDcmVhdGVzIGEgcHJvZHVjdGlvbi1tb2RlIENvbXBpbGVySG9zdCBmcm9tIHRoZSBwcmV2aW91c2x5IHNhdmVkIFxyXG4gICAqIGNvbmZpZ3VyYXRpb25cclxuICAgKiAgICBcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC4gXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcclxuICAgKi8gICBcclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbihyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbihyb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcclxuICAgIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUodGFyZ2V0KTtcclxuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSk7XHJcbiAgICBcclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgdHJ1ZSk7XHJcblxyXG4gICAgbGV0IGNvbXBpbGVycyA9IF8ucmVkdWNlKE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKSwgKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XHJcbiAgICAgIGFjY1t4XSA9IG5ldyBSZWFkT25seUNvbXBpbGVyKGN1ci5uYW1lLCBjdXIuY29tcGlsZXJWZXJzaW9uLCBjdXIuY29tcGlsZXJPcHRpb25zLCBjdXIuaW5wdXRNaW1lVHlwZXMpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICAvKiogICAgXHJcbiAgICogQ3JlYXRlcyBhIGRldmVsb3BtZW50LW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWQgXHJcbiAgICogY29uZmlndXJhdGlvbi5cclxuICAgKiAgICBcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnNCeU1pbWVUeXBlICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIENvbXBpbGVyQmFzZS4gQ3JlYXRlIHRoaXMgdmlhIHRoZSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpbiBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy1wYXJzZXIuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC4gXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcclxuICAgKi8gICBcclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xyXG4gICAgXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIGZhbHNlKTtcclxuICAgIFxyXG4gICAgXy5lYWNoKE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKSwgKHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBjb21waWxlcnNCeU1pbWVUeXBlW3hdLmNvbXBpbGVyT3B0aW9ucyA9IGN1ci5jb21waWxlck9wdGlvbnM7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcbiAgXHJcbiAgXHJcbiAgLyoqICBcclxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBjb21waWxlciBjb25maWd1cmF0aW9uIHRvIGEgZmlsZSB0aGF0IFxyXG4gICAqIHtAbGluayBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9ufSBjYW4gdXNlIHRvIHJlY3JlYXRlIHRoZSBjdXJyZW50IFxyXG4gICAqIGNvbXBpbGVyIGVudmlyb25tZW50XHJcbiAgICogICAgXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIENvbXBsZXRpb25cclxuICAgKi8gICBcclxuICBhc3luYyBzYXZlQ29uZmlndXJhdGlvbigpIHtcclxuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gXy5yZWR1Y2UoT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKSwgKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgdmFsID0ge1xyXG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXHJcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXHJcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXHJcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgYWNjW3hdID0gdmFsO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gICAgXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgZmlsZUNoYW5nZUNhY2hlOiB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRTYXZlZERhdGEoKSxcclxuICAgICAgY29tcGlsZXJzOiBzZXJpYWxpemVkQ29tcGlsZXJPcHRzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHRoaXMucm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcHpsaWIuZ3ppcChuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGluZm8pKSk7XHJcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKHRhcmdldCwgYnVmKTtcclxuICB9XHJcbiAgXHJcbiAgLyoqICBcclxuICAgKiBDb21waWxlcyBhIGZpbGUgYW5kIHJldHVybnMgdGhlIGNvbXBpbGVkIHJlc3VsdC5cclxuICAgKiAgICBcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVQYXRoICBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byBjb21waWxlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPG9iamVjdD59ICBBbiBPYmplY3Qgd2l0aCB0aGUgY29tcGlsZWQgcmVzdWx0XHJcbiAgICpcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSAgVGhlIHNvdXJjZSBjb2RlIGlmIHRoZSBmaWxlIHdhcyBhIHRleHQgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyfSBiaW5hcnlEYXRhICBUaGUgZmlsZSBpZiBpdCB3YXMgYSBiaW5hcnkgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSBzYXZlZCBpbiB0aGUgY2FjaGUuXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZGVwZW5kZW50RmlsZXMgIFRoZSBkZXBlbmRlbnQgZmlsZXMgcmV0dXJuZWQgZnJvbSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsaW5nIHRoZSBmaWxlLCBpZiBhbnkuXHJcbiAgICovICAgXHJcbiAgY29tcGlsZShmaWxlUGF0aCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnJlYWRPbmx5TW9kZSA/IHRoaXMuY29tcGlsZVJlYWRPbmx5KGZpbGVQYXRoKSA6IHRoaXMuZnVsbENvbXBpbGUoZmlsZVBhdGgpKTtcclxuICB9XHJcbiAgXHJcbiAgXHJcbiAgLyoqICBcclxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtb25seSBtb2RlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgIFxyXG4gIGFzeW5jIGNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkge1xyXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIGlmIChGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkpIHtcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKSBcclxuICAgICAgfTsgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxyXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHsgXHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xyXG5cclxuICAgICAgbGV0IHsgY29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfSA9IGF3YWl0IGNvbXBpbGVyLmdldChmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBhd2FpdCBjYWNoZS5nZXQoZmlsZVBhdGgpO1xyXG5cclxuICAgIGNvZGUgPSBjb2RlIHx8IGJpbmFyeURhdGE7XHJcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XHJcbiAgfVxyXG5cclxuICAvKiogIFxyXG4gICAqIEhhbmRsZXMgY29tcGlsYXRpb24gaW4gcmVhZC13cml0ZSBtb2RlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgICAgXHJcbiAgYXN5bmMgZnVsbENvbXBpbGUoZmlsZVBhdGgpIHtcclxuICAgIGQoYENvbXBpbGluZyAke2ZpbGVQYXRofWApO1xyXG4gICAgXHJcbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChmaWxlUGF0aCk7XHJcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiB0eXBlIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgZChgRmFsbGluZyBiYWNrIHRvIHBhc3N0aHJvdWdoIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICByZXR1cm4gYXdhaXQgY2FjaGUuZ2V0T3JGZXRjaChcclxuICAgICAgZmlsZVBhdGgsXHJcbiAgICAgIChmaWxlUGF0aCwgaGFzaEluZm8pID0+IHRoaXMuY29tcGlsZVVuY2FjaGVkKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKiAgXHJcbiAgICogSGFuZGxlcyBpbnZva2luZyBjb21waWxlcnMgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBjb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikge1xyXG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGJpbmFyeURhdGE6IGhhc2hJbmZvLmJpbmFyeURhdGEgfHwgYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGVQYXRoKSxcclxuICAgICAgICBtaW1lVHlwZTogaW5wdXRNaW1lVHlwZSxcclxuICAgICAgICBkZXBlbmRlbnRGaWxlczogW11cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgbGV0IGN0eCA9IHt9O1xyXG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuXHJcbiAgICBpZiAoIShhd2FpdCBjb21waWxlci5zaG91bGRDb21waWxlRmlsZShjb2RlLCBjdHgpKSkge1xyXG4gICAgICBkKGBDb21waWxlciByZXR1cm5lZCBmYWxzZSBmb3Igc2hvdWxkQ29tcGlsZUZpbGU6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKSwgZGVwZW5kZW50RmlsZXM6IFtdIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRlcGVuZGVudEZpbGVzID0gYXdhaXQgY29tcGlsZXIuZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgZChgVXNpbmcgY29tcGlsZXIgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShjb21waWxlci5jb21waWxlck9wdGlvbnMpfWApO1xyXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVyLmNvbXBpbGUoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPSBcclxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcclxuICAgIFxyXG4gICAgbGV0IGlzUGFzc3Rocm91Z2ggPSBcclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHwgXHJcbiAgICAgICFyZXN1bHQubWltZVR5cGUgfHwgXHJcbiAgICAgIENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbyk7XHJcbiAgICAgIFxyXG4gICAgaWYgKChmaW5hbEZvcm1zW3Jlc3VsdC5taW1lVHlwZV0gJiYgIXNob3VsZElubGluZUh0bWxpZnkpIHx8IGlzUGFzc3Rocm91Z2gpIHtcclxuICAgICAgLy8gR290IHNvbWV0aGluZyB3ZSBjYW4gdXNlIGluLWJyb3dzZXIsIGxldCdzIHJldHVybiBpdFxyXG4gICAgICByZXR1cm4gXy5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcclxuXHJcbiAgICAgIGhhc2hJbmZvID0gXy5hc3NpZ24oeyBzb3VyY2VDb2RlOiByZXN1bHQuY29kZSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9LCBoYXNoSW5mbyk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3Jlc3VsdC5taW1lVHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgICAgZChgUmVjdXJzaXZlIGNvbXBpbGUgZmFpbGVkIC0gaW50ZXJtZWRpYXRlIHJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGluZyAke2ZpbGVQYXRofSByZXN1bHRlZCBpbiBhIE1JTUUgdHlwZSBvZiAke3Jlc3VsdC5taW1lVHlwZX0sIHdoaWNoIHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb21waWxlVW5jYWNoZWQoXHJcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsIFxyXG4gICAgICAgIGhhc2hJbmZvLCBjb21waWxlcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogUHJlLWNhY2hlcyBhbiBlbnRpcmUgZGlyZWN0b3J5IG9mIGZpbGVzIHJlY3Vyc2l2ZWx5LiBVc3VhbGx5IHVzZWQgZm9yIFxyXG4gICAqIGJ1aWxkaW5nIGN1c3RvbSBjb21waWxlciB0b29saW5nLlxyXG4gICAqICAgIFxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcm9vdERpcmVjdG9yeSAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgdG8gY29tcGlsZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IHNob3VsZENvbXBpbGUgKG9wdGlvbmFsKSAgQSBGdW5jdGlvbiB3aGljaCBhbGxvd3MgdGhlIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlciB0byBkaXNhYmxlIGNvbXBpbGluZyBjZXJ0YWluIGZpbGVzLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IHRha2VzIGEgZnVsbHktcXVhbGlmaWVkIHBhdGggdG8gYSBmaWxlLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzaG91bGQgcmV0dXJuIGEgQm9vbGVhbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBDb21wbGV0aW9uLlxyXG4gICAqLyAgIFxyXG4gIGFzeW5jIGNvbXBpbGVBbGwocm9vdERpcmVjdG9yeSwgc2hvdWxkQ29tcGlsZT1udWxsKSB7XHJcbiAgICBsZXQgc2hvdWxkID0gc2hvdWxkQ29tcGlsZSB8fCBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZTt9O1xyXG5cclxuICAgIGF3YWl0IGZvckFsbEZpbGVzKHJvb3REaXJlY3RvcnksIChmKSA9PiB7XHJcbiAgICAgIGlmICghc2hvdWxkKGYpKSByZXR1cm47XHJcblxyXG4gICAgICBkKGBDb21waWxpbmcgJHtmfWApO1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlKGYsIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLypcclxuICAgKiBTeW5jIE1ldGhvZHNcclxuICAgKi9cclxuICAgXHJcbiAgY29tcGlsZVN5bmMoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seVN5bmMoZmlsZVBhdGgpIDogdGhpcy5mdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpKTtcclxuICB9XHJcbiAgXHJcbiAgc3RhdGljIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuICAgIFxyXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCB0cnVlKTtcclxuICAgIFxyXG4gICAgbGV0IGNvbXBpbGVycyA9IF8ucmVkdWNlKE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKSwgKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XHJcbiAgICAgIGFjY1t4XSA9IG5ldyBSZWFkT25seUNvbXBpbGVyKGN1ci5uYW1lLCBjdXIuY29tcGlsZXJWZXJzaW9uLCBjdXIuY29tcGlsZXJPcHRpb25zLCBjdXIuaW5wdXRNaW1lVHlwZXMpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG4gIFxyXG4gIHN0YXRpYyBjcmVhdGVGcm9tQ29uZmlndXJhdGlvblN5bmMocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xyXG4gICAgXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIGZhbHNlKTtcclxuICAgIFxyXG4gICAgXy5lYWNoKE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKSwgKHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBjb21waWxlcnNCeU1pbWVUeXBlW3hdLmNvbXBpbGVyT3B0aW9ucyA9IGN1ci5jb21waWxlck9wdGlvbnM7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcbiAgIFxyXG4gIHNhdmVDb25maWd1cmF0aW9uU3luYygpIHtcclxuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gXy5yZWR1Y2UoT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKSwgKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgdmFsID0ge1xyXG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXHJcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXHJcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXHJcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgYWNjW3hdID0gdmFsO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gICAgXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgZmlsZUNoYW5nZUNhY2hlOiB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRTYXZlZERhdGEoKSxcclxuICAgICAgY29tcGlsZXJzOiBzZXJpYWxpemVkQ29tcGlsZXJPcHRzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHRoaXMucm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gemxpYi5nemlwU3luYyhuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGluZm8pKSk7XHJcbiAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCwgYnVmKTtcclxuICB9XHJcbiAgXHJcbiAgY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkge1xyXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIGlmIChGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkpIHtcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGNvZGU6IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKSBcclxuICAgICAgfTsgICAgXHJcbiAgICB9ICBcclxuXHJcbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIG1pbWVUeXBlOiB0eXBlLCBcclxuICAgICAgICBjb2RlOiBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKSBcclxuICAgICAgfTsgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IEhlcmUsIHdlJ3JlIGJhc2ljYWxseSBvbmx5IHVzaW5nIHRoZSBjb21waWxlciBoZXJlIHRvIGZpbmRcclxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBDb21waWxlQ2FjaGVcclxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xyXG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XHJcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7IFxyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuXHJcbiAgICAgIGxldCB7IGNvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlIH0gPSBjb21waWxlci5nZXRTeW5jKGZpbGVQYXRoKTtcclxuICAgICAgcmV0dXJuIHsgY29kZTogY29kZSB8fCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICBsZXQge2NvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlfSA9IGNhY2hlLmdldFN5bmMoZmlsZVBhdGgpO1xyXG5cclxuICAgIGNvZGUgPSBjb2RlIHx8IGJpbmFyeURhdGE7XHJcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XHJcbiAgfVxyXG5cclxuICBmdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpIHtcclxuICAgIGQoYENvbXBpbGluZyAke2ZpbGVQYXRofWApO1xyXG5cclxuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhmaWxlUGF0aCk7XHJcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiB0eXBlIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgZChgRmFsbGluZyBiYWNrIHRvIHBhc3N0aHJvdWdoIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICByZXR1cm4gY2FjaGUuZ2V0T3JGZXRjaFN5bmMoXHJcbiAgICAgIGZpbGVQYXRoLFxyXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVVuY2FjaGVkU3luYyhmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XHJcbiAgICBsZXQgaW5wdXRNaW1lVHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYmluYXJ5RGF0YTogaGFzaEluZm8uYmluYXJ5RGF0YSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgpLFxyXG4gICAgICAgIG1pbWVUeXBlOiBpbnB1dE1pbWVUeXBlLFxyXG4gICAgICAgIGRlcGVuZGVudEZpbGVzOiBbXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIFxyXG4gICAgbGV0IGN0eCA9IHt9O1xyXG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuXHJcbiAgICBpZiAoIShjb21waWxlci5zaG91bGRDb21waWxlRmlsZVN5bmMoY29kZSwgY3R4KSkpIHtcclxuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyhjb2RlLCBmaWxlUGF0aCwgY3R4KTtcclxuXHJcbiAgICBsZXQgcmVzdWx0ID0gY29tcGlsZXIuY29tcGlsZVN5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPSBcclxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcclxuICAgICAgXHJcbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9IFxyXG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L3BsYWluJyB8fCBcclxuICAgICAgIXJlc3VsdC5taW1lVHlwZSB8fCBcclxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcclxuICAgICAgXHJcbiAgICBpZiAoKGZpbmFsRm9ybXNbcmVzdWx0Lm1pbWVUeXBlXSAmJiAhc2hvdWxkSW5saW5lSHRtbGlmeSkgfHwgaXNQYXNzdGhyb3VnaCkge1xyXG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XHJcbiAgICAgIHJldHVybiBfLmFzc2lnbihyZXN1bHQsIHtkZXBlbmRlbnRGaWxlc30pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZChgUmVjdXJzaXZlbHkgY29tcGlsaW5nIHJlc3VsdCBvZiAke2ZpbGVQYXRofSB3aXRoIG5vbi1maW5hbCBNSU1FIHR5cGUgJHtyZXN1bHQubWltZVR5cGV9LCBpbnB1dCB3YXMgJHtpbnB1dE1pbWVUeXBlfWApO1xyXG5cclxuICAgICAgaGFzaEluZm8gPSBfLmFzc2lnbih7IHNvdXJjZUNvZGU6IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0sIGhhc2hJbmZvKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsaW5nICR7ZmlsZVBhdGh9IHJlc3VsdGVkIGluIGEgTUlNRSB0eXBlIG9mICR7cmVzdWx0Lm1pbWVUeXBlfSwgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoXHJcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsIFxyXG4gICAgICAgIGhhc2hJbmZvLCBjb21waWxlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb21waWxlQWxsU3luYyhyb290RGlyZWN0b3J5LCBzaG91bGRDb21waWxlPW51bGwpIHtcclxuICAgIGxldCBzaG91bGQgPSBzaG91bGRDb21waWxlIHx8IGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO307XHJcblxyXG4gICAgZm9yQWxsRmlsZXNTeW5jKHJvb3REaXJlY3RvcnksIChmKSA9PiB7XHJcbiAgICAgIGlmICghc2hvdWxkKGYpKSByZXR1cm47XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVTeW5jKGYsIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLypcclxuICAgKiBPdGhlciBzdHVmZlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcGFzc3Rocm91Z2ggY29tcGlsZXIgXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgIFxyXG4gIGdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlWyd0ZXh0L3BsYWluJ107XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBldmVuIHRyeSB0byBjb21waWxlIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgaW5cclxuICAgKiBzb21lIGNhc2VzLCBjb250ZW50IHdpbGwgc3RpbGwgYmUgaW4gY2FjaGUgZXZlbiBpZiB0aGlzIHJldHVybnMgdHJ1ZSwgYW5kXHJcbiAgICogaW4gb3RoZXIgY2FzZXMgKGlzSW5Ob2RlTW9kdWxlcyksIHdlJ2xsIGtub3cgZXhwbGljaXRseSB0byBub3QgZXZlbiBib3RoZXJcclxuICAgKiBsb29raW5nIGluIHRoZSBjYWNoZS5cclxuICAgKiAgICBcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgIFxyXG4gIHN0YXRpYyBzaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykge1xyXG4gICAgcmV0dXJuIGhhc2hJbmZvLmlzTWluaWZpZWQgfHwgaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzIHx8IGhhc2hJbmZvLmhhc1NvdXJjZU1hcCB8fCBoYXNoSW5mby5pc0ZpbGVCaW5hcnk7XHJcbiAgfVxyXG59XHJcbiJdfQ==