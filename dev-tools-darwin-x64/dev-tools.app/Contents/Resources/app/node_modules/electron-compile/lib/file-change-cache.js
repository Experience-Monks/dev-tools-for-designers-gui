'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _promise = require('./promise');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sanitizePaths = require('./sanitize-paths');

var _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var d = require('debug')('electron-compile:file-change-cache');

/**
 * This class caches information about files and determines whether they have
 * changed contents or not. Most importantly, this class caches the hash of seen
 * files so that at development time, we don't have to recalculate them constantly.
 * 
 * This class is also the core of how electron-compile runs quickly in production
 * mode - after precompilation, the cache is serialized along with the rest of the
 * data in {@link CompilerHost}, so that when we load the app in production mode,
 * we don't end up calculating hashes of file content at all, only using the contents
 * of this cache.
 */

var FileChangedCache = (function () {
  function FileChangedCache(appRoot) {
    var failOnCacheMiss = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    _classCallCheck(this, FileChangedCache);

    this.appRoot = (0, _sanitizePaths2.default)(appRoot);
    this.failOnCacheMiss = failOnCacheMiss;
    this.changeCache = {};
  }

  /**  
   * Allows you to create a FileChangedCache from serialized data saved from 
   * {@link getSavedData}.
   *    
   * @param  {Object} data  Saved data from getSavedData.
   * 
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   * 
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   * 
   * @return {FileChangedCache}
   */

  _createClass(FileChangedCache, [{
    key: 'getHashForPath',

    /**  
     * Returns information about a given file, including its hash. This method is
     * the main method for this cache.
     *    
     * @param  {string} absoluteFilePath  The path to a file to retrieve info on.
     * 
     * @return {Promise<Object>}
     * 
     * @property {string} hash  The SHA1 hash of the file
     * @property {boolean} isMinified  True if the file is minified
     * @property {boolean} isInNodeModules  True if the file is in a library directory
     * @property {boolean} hasSourceMap  True if the file has a source map
     * @property {boolean} isFileBinary  True if the file is not a text file
     * @property {Buffer} binaryData (optional)  The buffer that was read if the file
     *                                           was binary and there was a cache miss.
     * @property {string} code (optional)  The string that was read if the file
     *                                     was text and there was a cache miss
     */
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(absoluteFilePath) {
        var cacheKey, cacheEntry, stat, ctime, size, _ref, digest, sourceCode, binaryData, info;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);

                if (this.appRoot) {
                  cacheKey = cacheKey.replace(this.appRoot, '');
                }

                // NB: We do this because x-require will include an absolute path from the
                // original built app and we need to still grok it
                if (this.originalAppRoot) {
                  cacheKey = cacheKey.replace(this.originalAppRoot, '');
                }

                cacheEntry = this.changeCache[cacheKey];

                if (!this.failOnCacheMiss) {
                  _context.next = 10;
                  break;
                }

                if (cacheEntry) {
                  _context.next = 9;
                  break;
                }

                d('Tried to read file cache entry for ' + absoluteFilePath);
                d('cacheKey: ' + cacheKey + ', appRoot: ' + this.appRoot + ', originalAppRoot: ' + this.originalAppRoot);
                throw new Error('Asked for ' + absoluteFilePath + ' but it was not precompiled!');

              case 9:
                return _context.abrupt('return', cacheEntry.info);

              case 10:
                _context.next = 12;
                return _promise.pfs.stat(absoluteFilePath);

              case 12:
                stat = _context.sent;
                ctime = stat.ctime.getTime();
                size = stat.size;

                if (!(!stat || !stat.isFile())) {
                  _context.next = 17;
                  break;
                }

                throw new Error('Can\'t stat ' + absoluteFilePath);

              case 17:
                if (!cacheEntry) {
                  _context.next = 22;
                  break;
                }

                if (!(cacheEntry.ctime >= ctime && cacheEntry.size === size)) {
                  _context.next = 20;
                  break;
                }

                return _context.abrupt('return', cacheEntry.info);

              case 20:

                d('Invalidating cache entry: ' + cacheEntry.ctime + ' === ' + ctime + ' && ' + cacheEntry.size + ' === ' + size);
                delete this.changeCache.cacheEntry;

              case 22:
                _context.next = 24;
                return this.calculateHashForFile(absoluteFilePath);

              case 24:
                _ref = _context.sent;
                digest = _ref.digest;
                sourceCode = _ref.sourceCode;
                binaryData = _ref.binaryData;
                info = {
                  hash: digest,
                  isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
                  isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
                  hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
                  isFileBinary: !!binaryData
                };

                this.changeCache[cacheKey] = { ctime: ctime, size: size, info: info };
                d('Cache entry for ' + cacheKey + ': ' + JSON.stringify(this.changeCache[cacheKey]));

                if (!binaryData) {
                  _context.next = 35;
                  break;
                }

                return _context.abrupt('return', _lodash2.default.extend({ binaryData: binaryData }, info));

              case 35:
                return _context.abrupt('return', _lodash2.default.extend({ sourceCode: sourceCode }, info));

              case 36:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getHashForPath(_x2) {
        return ref.apply(this, arguments);
      };
    })()

    /**  
     * Returns data that can passed to {@link loadFromData} to rehydrate this cache.
     *    
     * @return {Object}
     */

  }, {
    key: 'getSavedData',
    value: function getSavedData() {
      return { changeCache: this.changeCache, appRoot: this.appRoot };
    }

    /**  
     * Serializes this object's data to a file.
     *
     * @param {string} filePath  The path to save data to.
     *    
     * @return {Promise} Completion.
     */

  }, {
    key: 'save',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(filePath) {
        var toSave, buf;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                toSave = this.getSavedData();
                _context2.next = 3;
                return _promise.pzlib.gzip(new Buffer(JSON.stringify(toSave)));

              case 3:
                buf = _context2.sent;
                _context2.next = 6;
                return _promise.pfs.writeFile(filePath, buf);

              case 6:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function save(_x3) {
        return ref.apply(this, arguments);
      };
    })()
  }, {
    key: 'calculateHashForFile',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(absoluteFilePath) {
        var buf, encoding, _digest, sourceCode, digest;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _promise.pfs.readFile(absoluteFilePath);

              case 2:
                buf = _context3.sent;
                encoding = FileChangedCache.detectFileEncoding(buf);

                if (encoding) {
                  _context3.next = 7;
                  break;
                }

                _digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
                return _context3.abrupt('return', { sourceCode: null, digest: _digest, binaryData: buf });

              case 7:
                _context3.next = 9;
                return _promise.pfs.readFile(absoluteFilePath, encoding);

              case 9:
                sourceCode = _context3.sent;
                digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');
                return _context3.abrupt('return', { sourceCode: sourceCode, digest: digest, binaryData: null });

              case 12:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function calculateHashForFile(_x4) {
        return ref.apply(this, arguments);
      };
    })()
  }, {
    key: 'getHashForPathSync',
    value: function getHashForPathSync(absoluteFilePath) {
      var cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
      if (this.appRoot) {
        cacheKey = cacheKey.replace(this.appRoot, '');
      }

      // NB: We do this because x-require will include an absolute path from the
      // original built app and we need to still grok it
      if (this.originalAppRoot) {
        cacheKey = cacheKey.replace(this.originalAppRoot, '');
      }

      var cacheEntry = this.changeCache[cacheKey];

      if (this.failOnCacheMiss) {
        if (!cacheEntry) {
          d('Tried to read file cache entry for ' + absoluteFilePath);
          d('cacheKey: ' + cacheKey + ', appRoot: ' + this.appRoot + ', originalAppRoot: ' + this.originalAppRoot);
          throw new Error('Asked for ' + absoluteFilePath + ' but it was not precompiled!');
        }

        return cacheEntry.info;
      }

      var stat = _fs2.default.statSync(absoluteFilePath);
      var ctime = stat.ctime.getTime();
      var size = stat.size;
      if (!stat || !stat.isFile()) throw new Error('Can\'t stat ' + absoluteFilePath);

      if (cacheEntry) {
        if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
          return cacheEntry.info;
        }

        d('Invalidating cache entry: ' + cacheEntry.ctime + ' === ' + ctime + ' && ' + cacheEntry.size + ' === ' + size);
        delete this.changeCache.cacheEntry;
      }

      var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);

      var digest = _calculateHashForFile.digest;
      var sourceCode = _calculateHashForFile.sourceCode;
      var binaryData = _calculateHashForFile.binaryData;

      var info = {
        hash: digest,
        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
        isFileBinary: !!binaryData
      };

      this.changeCache[cacheKey] = { ctime: ctime, size: size, info: info };
      d('Cache entry for ' + cacheKey + ': ' + JSON.stringify(this.changeCache[cacheKey]));

      if (binaryData) {
        return _lodash2.default.extend({ binaryData: binaryData }, info);
      } else {
        return _lodash2.default.extend({ sourceCode: sourceCode }, info);
      }
    }
  }, {
    key: 'saveSync',
    value: function saveSync(filePath) {
      var toSave = this.getSavedData();

      var buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(toSave)));
      _fs2.default.writeFileSync(filePath, buf);
    }
  }, {
    key: 'calculateHashForFileSync',
    value: function calculateHashForFileSync(absoluteFilePath) {
      var buf = _fs2.default.readFileSync(absoluteFilePath);
      var encoding = FileChangedCache.detectFileEncoding(buf);

      if (!encoding) {
        var _digest2 = _crypto2.default.createHash('sha1').update(buf).digest('hex');
        return { sourceCode: null, digest: _digest2, binaryData: buf };
      }

      var sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);
      var digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

      return { sourceCode: sourceCode, digest: digest, binaryData: null };
    }

    /**  
     * Determines via some statistics whether a file is likely to be minified.
     *
     * @private
     */

  }], [{
    key: 'loadFromData',
    value: function loadFromData(data, appRoot) {
      var failOnCacheMiss = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

      var ret = new FileChangedCache(appRoot, failOnCacheMiss);
      ret.changeCache = data.changeCache;
      ret.originalAppRoot = data.appRoot;

      return ret;
    }

    /**  
     * Allows you to create a FileChangedCache from serialized data saved from 
     * {@link save}.
     *    
     * @param  {string} file  Saved data from save.
     * 
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     * 
     * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
     * 
     * @return {Promise<FileChangedCache>}
     */

  }, {
    key: 'loadFromFile',
    value: (function () {
      var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(file, appRoot) {
        var failOnCacheMiss = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
        var buf;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                d('Loading canned FileChangedCache from ' + file);

                _context4.next = 3;
                return _promise.pfs.readFile(file);

              case 3:
                buf = _context4.sent;
                _context4.t0 = FileChangedCache;
                _context4.t1 = JSON;
                _context4.next = 8;
                return _promise.pzlib.gunzip(buf);

              case 8:
                _context4.t2 = _context4.sent;
                _context4.t3 = _context4.t1.parse.call(_context4.t1, _context4.t2);
                _context4.t4 = appRoot;
                _context4.t5 = failOnCacheMiss;
                return _context4.abrupt('return', _context4.t0.loadFromData.call(_context4.t0, _context4.t3, _context4.t4, _context4.t5));

              case 13:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function loadFromFile(_x7, _x8) {
        return ref.apply(this, arguments);
      };
    })()
  }, {
    key: 'contentsAreMinified',
    value: function contentsAreMinified(source) {
      var length = source.length;
      if (length > 1024) length = 1024;

      var newlineCount = 0;

      // Roll through the characters and determine the average line length
      for (var i = 0; i < source.length; i++) {
        if (source[i] === '\n') newlineCount++;
      }

      // No Newlines? Any file other than a super small one is minified
      if (newlineCount === 0) {
        return length > 80;
      }

      var avgLineLength = length / newlineCount;
      return avgLineLength > 80;
    }

    /**  
     * Determines whether a path is in node_modules or the Electron init code
     *    
     * @private
     */

  }, {
    key: 'isInNodeModules',
    value: function isInNodeModules(filePath) {
      return !!(filePath.match(/node_modules[\\\/]/i) || filePath.match(/atom\.asar/));
    }

    /**
     * Returns whether a file has an inline source map
     *    
     * @private
     */

  }, {
    key: 'hasSourceMap',
    value: function hasSourceMap(sourceCode) {
      return sourceCode.lastIndexOf('//# sourceMap') > sourceCode.lastIndexOf('\n');
    }

    /**  
     * Determines the encoding of a file from the two most common encodings by trying
     * to decode it then looking for encoding errors
     *
     * @private
     */

  }, {
    key: 'detectFileEncoding',
    value: function detectFileEncoding(buffer) {
      if (buffer.length < 1) return false;
      var buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);

      var encodings = ['utf8', 'utf16le'];

      var encoding = _lodash2.default.find(encodings, function (x) {
        return !FileChangedCache.containsControlCharacters(buf.toString(x));
      });

      return encoding;
    }

    /**  
     * Determines whether a string is likely to be poorly encoded by looking for
     * control characters above a certain threshold
     *
     * @private
     */

  }, {
    key: 'containsControlCharacters',
    value: function containsControlCharacters(str) {
      var controlCount = 0;
      var threshold = str.length < 64 ? 2 : 16;

      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c === 65536 || c < 8) controlCount++;

        if (controlCount > threshold) return true;
      }

      if (controlCount === 0) return false;
      return controlCount / str.length < 0.02;
    }
  }]);

  return FileChangedCache;
})();

exports.default = FileChangedCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQSxJQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsb0NBQW9DLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFBQztJQWE1QyxnQkFBZ0I7QUFDbkMsV0FEbUIsZ0JBQWdCLENBQ3ZCLE9BQU8sRUFBeUI7UUFBdkIsZUFBZSx5REFBQyxLQUFLOzswQkFEdkIsZ0JBQWdCOztBQUVqQyxRQUFJLENBQUMsT0FBTyxHQUFHLDZCQUFpQixPQUFPLENBQUMsQ0FBQztBQUN6QyxRQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztBQUN2QyxRQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztHQUN2Qjs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7ZUFMa0IsZ0JBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQW9FZCxnQkFBZ0I7WUFDL0IsUUFBUSxFQVdSLFVBQVUsRUFZVixJQUFJLEVBQ0osS0FBSyxFQUNMLElBQUksUUFZSCxNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFFL0IsSUFBSTs7Ozs7O0FBdkNKLHdCQUFRLEdBQUcsNkJBQWlCLGdCQUFnQixDQUFDOztBQUNqRCxvQkFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0FBQ2hCLDBCQUFRLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2lCQUMvQzs7OztBQUFBLEFBSUQsb0JBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtBQUN4QiwwQkFBUSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQztpQkFDdkQ7O0FBRUcsMEJBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQzs7cUJBRXZDLElBQUksQ0FBQyxlQUFl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QUMzQzs7O1NBelVrQixnQkFBZ0I7OztrQkFBaEIsZ0JBQWdCIiwiZmlsZSI6ImZpbGUtY2hhbmdlLWNhY2hlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcclxuaW1wb3J0IHtwZnMsIHB6bGlifSBmcm9tICcuL3Byb21pc2UnO1xyXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgc2FuaXRpemVGaWxlUGF0aCBmcm9tICcuL3Nhbml0aXplLXBhdGhzJztcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOmZpbGUtY2hhbmdlLWNhY2hlJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjYWNoZXMgaW5mb3JtYXRpb24gYWJvdXQgZmlsZXMgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGV5IGhhdmVcclxuICogY2hhbmdlZCBjb250ZW50cyBvciBub3QuIE1vc3QgaW1wb3J0YW50bHksIHRoaXMgY2xhc3MgY2FjaGVzIHRoZSBoYXNoIG9mIHNlZW5cclxuICogZmlsZXMgc28gdGhhdCBhdCBkZXZlbG9wbWVudCB0aW1lLCB3ZSBkb24ndCBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoZW0gY29uc3RhbnRseS5cclxuICogXHJcbiAqIFRoaXMgY2xhc3MgaXMgYWxzbyB0aGUgY29yZSBvZiBob3cgZWxlY3Ryb24tY29tcGlsZSBydW5zIHF1aWNrbHkgaW4gcHJvZHVjdGlvblxyXG4gKiBtb2RlIC0gYWZ0ZXIgcHJlY29tcGlsYXRpb24sIHRoZSBjYWNoZSBpcyBzZXJpYWxpemVkIGFsb25nIHdpdGggdGhlIHJlc3Qgb2YgdGhlXHJcbiAqIGRhdGEgaW4ge0BsaW5rIENvbXBpbGVySG9zdH0sIHNvIHRoYXQgd2hlbiB3ZSBsb2FkIHRoZSBhcHAgaW4gcHJvZHVjdGlvbiBtb2RlLFxyXG4gKiB3ZSBkb24ndCBlbmQgdXAgY2FsY3VsYXRpbmcgaGFzaGVzIG9mIGZpbGUgY29udGVudCBhdCBhbGwsIG9ubHkgdXNpbmcgdGhlIGNvbnRlbnRzXHJcbiAqIG9mIHRoaXMgY2FjaGUuXHJcbiAqLyBcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUNoYW5nZWRDYWNoZSB7XHJcbiAgY29uc3RydWN0b3IoYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzPWZhbHNlKSB7XHJcbiAgICB0aGlzLmFwcFJvb3QgPSBzYW5pdGl6ZUZpbGVQYXRoKGFwcFJvb3QpO1xyXG4gICAgdGhpcy5mYWlsT25DYWNoZU1pc3MgPSBmYWlsT25DYWNoZU1pc3M7XHJcbiAgICB0aGlzLmNoYW5nZUNhY2hlID0ge307XHJcbiAgfVxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBGaWxlQ2hhbmdlZENhY2hlIGZyb20gc2VyaWFsaXplZCBkYXRhIHNhdmVkIGZyb20gXHJcbiAgICoge0BsaW5rIGdldFNhdmVkRGF0YX0uXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhICBTYXZlZCBkYXRhIGZyb20gZ2V0U2F2ZWREYXRhLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmYWlsT25DYWNoZU1pc3MgKG9wdGlvbmFsKSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgdGhyb3cuXHJcbiAgICogXHJcbiAgICogQHJldHVybiB7RmlsZUNoYW5nZWRDYWNoZX1cclxuICAgKi8gICBcclxuICBzdGF0aWMgbG9hZEZyb21EYXRhKGRhdGEsIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz10cnVlKSB7XHJcbiAgICBsZXQgcmV0ID0gbmV3IEZpbGVDaGFuZ2VkQ2FjaGUoYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzKTtcclxuICAgIHJldC5jaGFuZ2VDYWNoZSA9IGRhdGEuY2hhbmdlQ2FjaGU7XHJcbiAgICByZXQub3JpZ2luYWxBcHBSb290ID0gZGF0YS5hcHBSb290O1xyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqICBcclxuICAgKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSBzZXJpYWxpemVkIGRhdGEgc2F2ZWQgZnJvbSBcclxuICAgKiB7QGxpbmsgc2F2ZX0uXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxlICBTYXZlZCBkYXRhIGZyb20gc2F2ZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmFpbE9uQ2FjaGVNaXNzIChvcHRpb25hbCkgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIHRocm93LlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8RmlsZUNoYW5nZWRDYWNoZT59XHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGxvYWRGcm9tRmlsZShmaWxlLCBhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9dHJ1ZSkge1xyXG4gICAgZChgTG9hZGluZyBjYW5uZWQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICR7ZmlsZX1gKTtcclxuICBcclxuICAgIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZSk7XHJcbiAgICByZXR1cm4gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSksIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcyk7XHJcbiAgfVxyXG4gIFxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBhIGdpdmVuIGZpbGUsIGluY2x1ZGluZyBpdHMgaGFzaC4gVGhpcyBtZXRob2QgaXNcclxuICAgKiB0aGUgbWFpbiBtZXRob2QgZm9yIHRoaXMgY2FjaGUuXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhYnNvbHV0ZUZpbGVQYXRoICBUaGUgcGF0aCB0byBhIGZpbGUgdG8gcmV0cmlldmUgaW5mbyBvbi5cclxuICAgKiBcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XHJcbiAgICogXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2ggIFRoZSBTSEExIGhhc2ggb2YgdGhlIGZpbGVcclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWluaWZpZWQgIFRydWUgaWYgdGhlIGZpbGUgaXMgbWluaWZpZWRcclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Ob2RlTW9kdWxlcyAgVHJ1ZSBpZiB0aGUgZmlsZSBpcyBpbiBhIGxpYnJhcnkgZGlyZWN0b3J5XHJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBoYXNTb3VyY2VNYXAgIFRydWUgaWYgdGhlIGZpbGUgaGFzIGEgc291cmNlIG1hcFxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNGaWxlQmluYXJ5ICBUcnVlIGlmIHRoZSBmaWxlIGlzIG5vdCBhIHRleHQgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyfSBiaW5hcnlEYXRhIChvcHRpb25hbCkgIFRoZSBidWZmZXIgdGhhdCB3YXMgcmVhZCBpZiB0aGUgZmlsZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBiaW5hcnkgYW5kIHRoZXJlIHdhcyBhIGNhY2hlIG1pc3MuXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgKG9wdGlvbmFsKSAgVGhlIHN0cmluZyB0aGF0IHdhcyByZWFkIGlmIHRoZSBmaWxlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIHRleHQgYW5kIHRoZXJlIHdhcyBhIGNhY2hlIG1pc3NcclxuICAgKi8gICBcclxuICBhc3luYyBnZXRIYXNoRm9yUGF0aChhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgaWYgKHRoaXMuYXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5hcHBSb290LCAnJyk7XHJcbiAgICB9IFxyXG4gICAgXHJcbiAgICAvLyBOQjogV2UgZG8gdGhpcyBiZWNhdXNlIHgtcmVxdWlyZSB3aWxsIGluY2x1ZGUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHRoZSBcclxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XHJcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMub3JpZ2luYWxBcHBSb290LCAnJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxldCBjYWNoZUVudHJ5ID0gdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV07XHJcbiAgICBcclxuICAgIGlmICh0aGlzLmZhaWxPbkNhY2hlTWlzcykge1xyXG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICBkKGBUcmllZCB0byByZWFkIGZpbGUgY2FjaGUgZW50cnkgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuICAgICAgICBkKGBjYWNoZUtleTogJHtjYWNoZUtleX0sIGFwcFJvb3Q6ICR7dGhpcy5hcHBSb290fSwgb3JpZ2luYWxBcHBSb290OiAke3RoaXMub3JpZ2luYWxBcHBSb290fWApO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XHJcbiAgICB9XHJcbiAgICAgICAgXHJcbiAgICBsZXQgc3RhdCA9IGF3YWl0IHBmcy5zdGF0KGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XHJcbiAgICBsZXQgc2l6ZSA9IHN0YXQuc2l6ZTtcclxuICAgIGlmICghc3RhdCB8fCAhc3RhdC5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGF0ICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuICAgIFxyXG4gICAgaWYgKGNhY2hlRW50cnkpIHtcclxuICAgICAgaWYgKGNhY2hlRW50cnkuY3RpbWUgPj0gY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZChgSW52YWxpZGF0aW5nIGNhY2hlIGVudHJ5OiAke2NhY2hlRW50cnkuY3RpbWV9ID09PSAke2N0aW1lfSAmJiAke2NhY2hlRW50cnkuc2l6ZX0gPT09ICR7c2l6ZX1gKTtcclxuICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlQ2FjaGUuY2FjaGVFbnRyeTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgbGV0IHtkaWdlc3QsIHNvdXJjZUNvZGUsIGJpbmFyeURhdGF9ID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVIYXNoRm9yRmlsZShhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgbGV0IGluZm8gPSB7XHJcbiAgICAgIGhhc2g6IGRpZ2VzdCxcclxuICAgICAgaXNNaW5pZmllZDogRmlsZUNoYW5nZWRDYWNoZS5jb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZUNvZGUgfHwgJycpLFxyXG4gICAgICBpc0luTm9kZU1vZHVsZXM6IEZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKGFic29sdXRlRmlsZVBhdGgpLFxyXG4gICAgICBoYXNTb3VyY2VNYXA6IEZpbGVDaGFuZ2VkQ2FjaGUuaGFzU291cmNlTWFwKHNvdXJjZUNvZGUgfHwgJycpLFxyXG4gICAgICBpc0ZpbGVCaW5hcnk6ICEhYmluYXJ5RGF0YVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0gPSB7IGN0aW1lLCBzaXplLCBpbmZvIH07XHJcbiAgICBkKGBDYWNoZSBlbnRyeSBmb3IgJHtjYWNoZUtleX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0pfWApO1xyXG5cclxuICAgIGlmIChiaW5hcnlEYXRhKSB7XHJcbiAgICAgIHJldHVybiBfLmV4dGVuZCh7YmluYXJ5RGF0YX0sIGluZm8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtzb3VyY2VDb2RlfSwgaW5mbyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogUmV0dXJucyBkYXRhIHRoYXQgY2FuIHBhc3NlZCB0byB7QGxpbmsgbG9hZEZyb21EYXRhfSB0byByZWh5ZHJhdGUgdGhpcyBjYWNoZS5cclxuICAgKiAgICBcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovICAgXHJcbiAgZ2V0U2F2ZWREYXRhKCkge1xyXG4gICAgcmV0dXJuIHsgY2hhbmdlQ2FjaGU6IHRoaXMuY2hhbmdlQ2FjaGUsIGFwcFJvb3Q6IHRoaXMuYXBwUm9vdCB9O1xyXG4gIH1cclxuICAgIFxyXG4gIC8qKiAgXHJcbiAgICogU2VyaWFsaXplcyB0aGlzIG9iamVjdCdzIGRhdGEgdG8gYSBmaWxlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoICBUaGUgcGF0aCB0byBzYXZlIGRhdGEgdG8uXHJcbiAgICogICAgXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQ29tcGxldGlvbi5cclxuICAgKi8gICBcclxuICBhc3luYyBzYXZlKGZpbGVQYXRoKSB7XHJcbiAgICBsZXQgdG9TYXZlID0gdGhpcy5nZXRTYXZlZERhdGEoKTtcclxuICAgIFxyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XHJcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBidWYpO1xyXG4gIH1cclxuICBcclxuICBhc3luYyBjYWxjdWxhdGVIYXNoRm9yRmlsZShhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcclxuICAgIFxyXG4gICAgaWYgKCFlbmNvZGluZykge1xyXG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1ZiB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgc291cmNlQ29kZSA9IGF3YWl0IHBmcy5yZWFkRmlsZShhYnNvbHV0ZUZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc291cmNlQ29kZSwgJ3V0ZjgnKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge3NvdXJjZUNvZGUsIGRpZ2VzdCwgYmluYXJ5RGF0YTogbnVsbCB9O1xyXG4gIH1cclxuICBcclxuICBnZXRIYXNoRm9yUGF0aFN5bmMoYWJzb2x1dGVGaWxlUGF0aCkge1xyXG4gICAgbGV0IGNhY2hlS2V5ID0gc2FuaXRpemVGaWxlUGF0aChhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGlmICh0aGlzLmFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMuYXBwUm9vdCwgJycpO1xyXG4gICAgfSBcclxuICAgIFxyXG4gICAgLy8gTkI6IFdlIGRvIHRoaXMgYmVjYXVzZSB4LXJlcXVpcmUgd2lsbCBpbmNsdWRlIGFuIGFic29sdXRlIHBhdGggZnJvbSB0aGUgXHJcbiAgICAvLyBvcmlnaW5hbCBidWlsdCBhcHAgYW5kIHdlIG5lZWQgdG8gc3RpbGwgZ3JvayBpdFxyXG4gICAgaWYgKHRoaXMub3JpZ2luYWxBcHBSb290KSB7XHJcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLm9yaWdpbmFsQXBwUm9vdCwgJycpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgY2FjaGVFbnRyeSA9IHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5mYWlsT25DYWNoZU1pc3MpIHtcclxuICAgICAgaWYgKCFjYWNoZUVudHJ5KSB7XHJcbiAgICAgICAgZChgVHJpZWQgdG8gcmVhZCBmaWxlIGNhY2hlIGVudHJ5IGZvciAke2Fic29sdXRlRmlsZVBhdGh9YCk7XHJcbiAgICAgICAgZChgY2FjaGVLZXk6ICR7Y2FjaGVLZXl9LCBhcHBSb290OiAke3RoaXMuYXBwUm9vdH0sIG9yaWdpbmFsQXBwUm9vdDogJHt0aGlzLm9yaWdpbmFsQXBwUm9vdH1gKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIGZvciAke2Fic29sdXRlRmlsZVBhdGh9IGJ1dCBpdCB3YXMgbm90IHByZWNvbXBpbGVkIWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xyXG4gICAgfVxyXG4gICAgICAgIFxyXG4gICAgbGV0IHN0YXQgPSBmcy5zdGF0U3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xyXG4gICAgbGV0IHNpemUgPSBzdGF0LnNpemU7XHJcbiAgICBpZiAoIXN0YXQgfHwgIXN0YXQuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhdCAke2Fic29sdXRlRmlsZVBhdGh9YCk7XHJcbiAgICBcclxuICAgIGlmIChjYWNoZUVudHJ5KSB7XHJcbiAgICAgIGlmIChjYWNoZUVudHJ5LmN0aW1lID49IGN0aW1lICYmIGNhY2hlRW50cnkuc2l6ZSA9PT0gc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGQoYEludmFsaWRhdGluZyBjYWNoZSBlbnRyeTogJHtjYWNoZUVudHJ5LmN0aW1lfSA9PT0gJHtjdGltZX0gJiYgJHtjYWNoZUVudHJ5LnNpemV9ID09PSAke3NpemV9YCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZUNhY2hlLmNhY2hlRW50cnk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxldCB7ZGlnZXN0LCBzb3VyY2VDb2RlLCBiaW5hcnlEYXRhfSA9IHRoaXMuY2FsY3VsYXRlSGFzaEZvckZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgaGFzaDogZGlnZXN0LFxyXG4gICAgICBpc01pbmlmaWVkOiBGaWxlQ2hhbmdlZENhY2hlLmNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzSW5Ob2RlTW9kdWxlczogRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoYWJzb2x1dGVGaWxlUGF0aCksXHJcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzRmlsZUJpbmFyeTogISFiaW5hcnlEYXRhXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSA9IHsgY3RpbWUsIHNpemUsIGluZm8gfTtcclxuICAgIGQoYENhY2hlIGVudHJ5IGZvciAke2NhY2hlS2V5fTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSl9YCk7XHJcblxyXG4gICAgaWYgKGJpbmFyeURhdGEpIHtcclxuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtiaW5hcnlEYXRhfSwgaW5mbyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gXy5leHRlbmQoe3NvdXJjZUNvZGV9LCBpbmZvKTtcclxuICAgIH1cclxuICB9XHJcbiAgICBcclxuICBzYXZlU3luYyhmaWxlUGF0aCkge1xyXG4gICAgbGV0IHRvU2F2ZSA9IHRoaXMuZ2V0U2F2ZWREYXRhKCk7XHJcblxyXG4gICAgbGV0IGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XHJcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBidWYpO1xyXG4gIH1cclxuICAgIFxyXG4gIGNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcclxuICAgIFxyXG4gICAgaWYgKCFlbmNvZGluZykge1xyXG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1Zn07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxldCBzb3VyY2VDb2RlID0gZnMucmVhZEZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgsIGVuY29kaW5nKTtcclxuICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XHJcbiAgICBcclxuICAgIHJldHVybiB7c291cmNlQ29kZSwgZGlnZXN0LCBiaW5hcnlEYXRhOiBudWxsfTsgIFxyXG4gIH1cclxuICBcclxuICBcclxuICAvKiogIFxyXG4gICAqIERldGVybWluZXMgdmlhIHNvbWUgc3RhdGlzdGljcyB3aGV0aGVyIGEgZmlsZSBpcyBsaWtlbHkgdG8gYmUgbWluaWZpZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgIFxyXG4gIHN0YXRpYyBjb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZSkge1xyXG4gICAgbGV0IGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XHJcbiAgICBpZiAobGVuZ3RoID4gMTAyNCkgbGVuZ3RoID0gMTAyNDtcclxuXHJcbiAgICBsZXQgbmV3bGluZUNvdW50ID0gMDtcclxuXHJcbiAgICAvLyBSb2xsIHRocm91Z2ggdGhlIGNoYXJhY3RlcnMgYW5kIGRldGVybWluZSB0aGUgYXZlcmFnZSBsaW5lIGxlbmd0aFxyXG4gICAgZm9yKGxldCBpPTA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gJ1xcbicpIG5ld2xpbmVDb3VudCsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIE5ld2xpbmVzPyBBbnkgZmlsZSBvdGhlciB0aGFuIGEgc3VwZXIgc21hbGwgb25lIGlzIG1pbmlmaWVkXHJcbiAgICBpZiAobmV3bGluZUNvdW50ID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAobGVuZ3RoID4gODApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBhdmdMaW5lTGVuZ3RoID0gbGVuZ3RoIC8gbmV3bGluZUNvdW50O1xyXG4gICAgcmV0dXJuIChhdmdMaW5lTGVuZ3RoID4gODApO1xyXG4gIH1cclxuXHJcbiAgXHJcbiAgLyoqICBcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwYXRoIGlzIGluIG5vZGVfbW9kdWxlcyBvciB0aGUgRWxlY3Ryb24gaW5pdCBjb2RlXHJcbiAgICogICAgXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICBcclxuICBzdGF0aWMgaXNJbk5vZGVNb2R1bGVzKGZpbGVQYXRoKSB7XHJcbiAgICByZXR1cm4gISEoZmlsZVBhdGgubWF0Y2goL25vZGVfbW9kdWxlc1tcXFxcXFwvXS9pKSB8fCBmaWxlUGF0aC5tYXRjaCgvYXRvbVxcLmFzYXIvKSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgZmlsZSBoYXMgYW4gaW5saW5lIHNvdXJjZSBtYXBcclxuICAgKiAgICBcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLyAgIFxyXG4gIHN0YXRpYyBoYXNTb3VyY2VNYXAoc291cmNlQ29kZSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZUNvZGUubGFzdEluZGV4T2YoJy8vIyBzb3VyY2VNYXAnKSA+IHNvdXJjZUNvZGUubGFzdEluZGV4T2YoJ1xcbicpO1xyXG4gIH1cclxuICBcclxuICAvKiogIFxyXG4gICAqIERldGVybWluZXMgdGhlIGVuY29kaW5nIG9mIGEgZmlsZSBmcm9tIHRoZSB0d28gbW9zdCBjb21tb24gZW5jb2RpbmdzIGJ5IHRyeWluZ1xyXG4gICAqIHRvIGRlY29kZSBpdCB0aGVuIGxvb2tpbmcgZm9yIGVuY29kaW5nIGVycm9yc1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICBcclxuICBzdGF0aWMgZGV0ZWN0RmlsZUVuY29kaW5nKGJ1ZmZlcikge1xyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKSByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgYnVmID0gKGJ1ZmZlci5sZW5ndGggPCA0MDk2ID8gYnVmZmVyIDogYnVmZmVyLnNsaWNlKDAsIDQwOTYpKTtcclxuICAgIFxyXG4gICAgY29uc3QgZW5jb2RpbmdzID0gWyd1dGY4JywgJ3V0ZjE2bGUnXTtcclxuICAgIFxyXG4gICAgbGV0IGVuY29kaW5nID0gXy5maW5kKFxyXG4gICAgICBlbmNvZGluZ3MsIFxyXG4gICAgICAoeCkgPT4gIUZpbGVDaGFuZ2VkQ2FjaGUuY29udGFpbnNDb250cm9sQ2hhcmFjdGVycyhidWYudG9TdHJpbmcoeCkpKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGVuY29kaW5nO1xyXG4gIH1cclxuICBcclxuICAvKiogIFxyXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBpcyBsaWtlbHkgdG8gYmUgcG9vcmx5IGVuY29kZWQgYnkgbG9va2luZyBmb3JcclxuICAgKiBjb250cm9sIGNoYXJhY3RlcnMgYWJvdmUgYSBjZXJ0YWluIHRocmVzaG9sZFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICBcclxuICBzdGF0aWMgY29udGFpbnNDb250cm9sQ2hhcmFjdGVycyhzdHIpIHtcclxuICAgIGxldCBjb250cm9sQ291bnQgPSAwO1xyXG4gICAgbGV0IHRocmVzaG9sZCA9IChzdHIubGVuZ3RoIDwgNjQgPyAyIDogMTYpO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgaWYgKGMgPT09IDY1NTM2IHx8IGMgPCA4KSBjb250cm9sQ291bnQrKztcclxuICAgICAgXHJcbiAgICAgIGlmIChjb250cm9sQ291bnQgPiB0aHJlc2hvbGQpIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoY29udHJvbENvdW50ID09PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKGNvbnRyb2xDb3VudCAvIHN0ci5sZW5ndGgpIDwgMC4wMjtcclxuICB9XHJcbn1cclxuIl19